import { LogLevelDesc } from 'loglevel';
type WalletSdkInput = {
    networkId?: number;
    dAppId: string;
    logLevel?: LogLevelDesc;
};
export declare const Network: {
    readonly Mainnet: 1;
    readonly Stokenet: 2;
    readonly Adapanet: 10;
    readonly Nebunet: 11;
    readonly Gilganet: 32;
    readonly Enkinet: 33;
    readonly Hammunet: 34;
};
declare const WalletSdk: ({ networkId, dAppId, logLevel, }: WalletSdkInput) => {
    destroy: () => void;
    __subjects: {
        outgoingMessageSubject: import("rxjs").Subject<{
            requestId: string;
            items: ({
                numberOfAccounts?: number | undefined;
                requestType: "oneTimeAccountsRead";
                requiresProofOfOwnership: boolean;
            } | {
                message?: string | undefined;
                blobs?: string[] | undefined;
                requestType: "sendTransactionWrite";
                transactionManifest: string;
                version: number;
            })[];
            metadata: {
                networkId: number;
                dAppId: string;
            };
        }>;
        incomingMessageSubject: import("rxjs").Subject<{
            requestId: string;
            items: ({
                requestType: "oneTimeAccountsRead";
                accounts: {
                    account: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    };
                    challenge: string;
                    signature: string;
                }[];
            } | {
                requestType: "oneTimeAccountsRead";
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
            } | {
                requestType: "ongoingAccountsRead";
                accounts: {
                    account: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    };
                    challenge: string;
                    signature: string;
                }[];
            } | {
                requestType: "ongoingAccountsRead";
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
            } | {
                requestType: "oneTimePersonaDataRead";
                fields: {
                    value: string;
                    field: string;
                }[];
            } | {
                requestType: "ongoingPersonaDataRead";
                fields: {
                    value: string;
                    field: string;
                }[];
            } | {
                requestType: "usePersonaRead";
                id: string;
            } | {
                requestType: "loginRead";
                personaId: string;
            } | {
                challenge: string;
                signature: string;
                requestType: "loginRead";
                personaId: string;
                publicKey: string;
                identityComponentAddress: string;
            } | {
                requestType: "sendTransactionWrite";
                transactionIntentHash: string;
            })[];
        } | {
            message?: string | undefined;
            requestId: string;
            error: "rejectedByUser";
        } | {
            eventType: "receivedByExtension";
            requestId: string;
        }>;
        responseSubject: import("rxjs").Subject<{
            requestId: string;
            items: ({
                requestType: "oneTimeAccountsRead";
                accounts: {
                    account: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    };
                    challenge: string;
                    signature: string;
                }[];
            } | {
                requestType: "oneTimeAccountsRead";
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
            } | {
                requestType: "ongoingAccountsRead";
                accounts: {
                    account: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    };
                    challenge: string;
                    signature: string;
                }[];
            } | {
                requestType: "ongoingAccountsRead";
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
            } | {
                requestType: "oneTimePersonaDataRead";
                fields: {
                    value: string;
                    field: string;
                }[];
            } | {
                requestType: "ongoingPersonaDataRead";
                fields: {
                    value: string;
                    field: string;
                }[];
            } | {
                requestType: "usePersonaRead";
                id: string;
            } | {
                requestType: "loginRead";
                personaId: string;
            } | {
                challenge: string;
                signature: string;
                requestType: "loginRead";
                personaId: string;
                publicKey: string;
                identityComponentAddress: string;
            } | {
                requestType: "sendTransactionWrite";
                transactionIntentHash: string;
            })[];
        } | {
            message?: string | undefined;
            requestId: string;
            error: "rejectedByUser";
        } | import("./helpers/error").SdkError>;
        messageLifeCycleEventSubject: import("rxjs").Subject<{
            eventType: "receivedByExtension";
            requestId: string;
        }>;
        dispatchEventSubject: import("rxjs").Subject<import("./messages/_types").MessageDispatch>;
    };
    request: <Input extends Partial<{
        oneTimeAccountsWithoutProofOfOwnership: {
            numberOfAccounts?: number | undefined;
        };
    }>, Output extends keyof Input extends "oneTimeAccountsWithoutProofOfOwnership" ? { [Key in keyof Input]: (x: {
        oneTimeAccountsWithoutProofOfOwnership: {
            oneTimeAccounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
        };
    }[Key]) => void; }[keyof Input] extends (x: infer T) => void ? T : never : never>(input: Input, callbackFns?: Partial<import("./messages/events/_types").CallbackFns>) => import("neverthrow").ResultAsync<Output, import("./helpers/error").SdkError>;
    sendTransaction: (input: {
        transactionManifest: string;
        version: number;
        blobs?: string[] | undefined;
        message?: string | undefined;
    }, callbackFns?: Partial<import("./messages/events/_types").CallbackFns>) => import("neverthrow").ResultAsync<{
        transactionIntentHash: string;
    }, import("./helpers/error").SdkError>;
};
export type WalletSdk = ReturnType<typeof WalletSdk>;
export default WalletSdk;
export { ManifestBuilder } from './manifest-builder';
export * from './scrypto-value';
export { requestBuilder } from './request-builder';
export { requestItem } from './IO/request-items/request-item';
