var Wn = Object.defineProperty;
var qn = (t, e, n) => e in t ? Wn(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var _e = (t, e, n) => (qn(t, typeof e != "symbol" ? e + "" : e, n), n);
var ot = function(t, e) {
  return ot = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var s in r)
      Object.prototype.hasOwnProperty.call(r, s) && (n[s] = r[s]);
  }, ot(t, e);
};
function ie(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  ot(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
function Bn(t, e, n, r) {
  function s(i) {
    return i instanceof n ? i : new n(function(o) {
      o(i);
    });
  }
  return new (n || (n = Promise))(function(i, o) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (_) {
        o(_);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (_) {
        o(_);
      }
    }
    function u(l) {
      l.done ? i(l.value) : s(l.value).then(a, c);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function tn(t, e) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, s && (i = u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, u[1])).done)
          return i;
        switch (s = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
          case 0:
          case 1:
            i = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < i[1]) {
              n.label = i[1], i = u;
              break;
            }
            if (i && n.label < i[2]) {
              n.label = i[2], n.ops.push(u);
              break;
            }
            i[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = e.call(t, n);
      } catch (l) {
        u = [6, l], s = 0;
      } finally {
        r = i = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Ee(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function me(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), s, i = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(s = r.next()).done; )
      i.push(s.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return i;
}
function ye(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, s = e.length, i; r < s; r++)
      (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)), i[r] = e[r]);
  return t.concat(i || Array.prototype.slice.call(e));
}
function xe(t) {
  return this instanceof xe ? (this.v = t, this) : new xe(t);
}
function Vn(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []), s, i = [];
  return s = {}, o("next"), o("throw"), o("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function o(m) {
    r[m] && (s[m] = function(b) {
      return new Promise(function($, p) {
        i.push([m, b, $, p]) > 1 || a(m, b);
      });
    });
  }
  function a(m, b) {
    try {
      c(r[m](b));
    } catch ($) {
      _(i[0][3], $);
    }
  }
  function c(m) {
    m.value instanceof xe ? Promise.resolve(m.value.v).then(u, l) : _(i[0][2], m);
  }
  function u(m) {
    a("next", m);
  }
  function l(m) {
    a("throw", m);
  }
  function _(m, b) {
    m(b), i.shift(), i.length && a(i[0][0], i[0][1]);
  }
}
function Fn(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], n;
  return e ? e.call(t) : (t = typeof Ee == "function" ? Ee(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(i) {
    n[i] = t[i] && function(o) {
      return new Promise(function(a, c) {
        o = t[i](o), s(a, c, o.done, o.value);
      });
    };
  }
  function s(i, o, a, c) {
    Promise.resolve(c).then(function(u) {
      i({ value: u, done: a });
    }, o);
  }
}
function C(t) {
  return typeof t == "function";
}
function At(t) {
  var e = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, n = t(e);
  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;
}
var et = At(function(t) {
  return function(n) {
    t(this), this.message = n ? n.length + ` errors occurred during unsubscription:
` + n.map(function(r, s) {
      return s + 1 + ") " + r.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = n;
  };
});
function Ve(t, e) {
  if (t) {
    var n = t.indexOf(e);
    0 <= n && t.splice(n, 1);
  }
}
var Ie = function() {
  function t(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return t.prototype.unsubscribe = function() {
    var e, n, r, s, i;
    if (!this.closed) {
      this.closed = !0;
      var o = this._parentage;
      if (o)
        if (this._parentage = null, Array.isArray(o))
          try {
            for (var a = Ee(o), c = a.next(); !c.done; c = a.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (p) {
            e = { error: p };
          } finally {
            try {
              c && !c.done && (n = a.return) && n.call(a);
            } finally {
              if (e)
                throw e.error;
            }
          }
        else
          o.remove(this);
      var l = this.initialTeardown;
      if (C(l))
        try {
          l();
        } catch (p) {
          i = p instanceof et ? p.errors : [p];
        }
      var _ = this._finalizers;
      if (_) {
        this._finalizers = null;
        try {
          for (var m = Ee(_), b = m.next(); !b.done; b = m.next()) {
            var $ = b.value;
            try {
              Mt($);
            } catch (p) {
              i = i ?? [], p instanceof et ? i = ye(ye([], me(i)), me(p.errors)) : i.push(p);
            }
          }
        } catch (p) {
          r = { error: p };
        } finally {
          try {
            b && !b.done && (s = m.return) && s.call(m);
          } finally {
            if (r)
              throw r.error;
          }
        }
      }
      if (i)
        throw new et(i);
    }
  }, t.prototype.add = function(e) {
    var n;
    if (e && e !== this)
      if (this.closed)
        Mt(e);
      else {
        if (e instanceof t) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(e);
      }
  }, t.prototype._hasParent = function(e) {
    var n = this._parentage;
    return n === e || Array.isArray(n) && n.includes(e);
  }, t.prototype._addParent = function(e) {
    var n = this._parentage;
    this._parentage = Array.isArray(n) ? (n.push(e), n) : n ? [n, e] : e;
  }, t.prototype._removeParent = function(e) {
    var n = this._parentage;
    n === e ? this._parentage = null : Array.isArray(n) && Ve(n, e);
  }, t.prototype.remove = function(e) {
    var n = this._finalizers;
    n && Ve(n, e), e instanceof t && e._removeParent(this);
  }, t.EMPTY = function() {
    var e = new t();
    return e.closed = !0, e;
  }(), t;
}(), nn = Ie.EMPTY;
function rn(t) {
  return t instanceof Ie || t && "closed" in t && C(t.remove) && C(t.add) && C(t.unsubscribe);
}
function Mt(t) {
  C(t) ? t() : t.unsubscribe();
}
var kt = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, at = {
  setTimeout: function(t, e) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var s = at.delegate;
    return s != null && s.setTimeout ? s.setTimeout.apply(s, ye([t, e], me(n))) : setTimeout.apply(void 0, ye([t, e], me(n)));
  },
  clearTimeout: function(t) {
    var e = at.delegate;
    return ((e == null ? void 0 : e.clearTimeout) || clearTimeout)(t);
  },
  delegate: void 0
};
function sn(t) {
  at.setTimeout(function() {
    throw t;
  });
}
function ut() {
}
var We = null;
function Be(t) {
  if (kt.useDeprecatedSynchronousErrorHandling) {
    var e = !We;
    if (e && (We = { errorThrown: !1, error: null }), t(), e) {
      var n = We, r = n.errorThrown, s = n.error;
      if (We = null, r)
        throw s;
    }
  } else
    t();
}
var Pt = function(t) {
  ie(e, t);
  function e(n) {
    var r = t.call(this) || this;
    return r.isStopped = !1, n ? (r.destination = n, rn(n) && n.add(r)) : r.destination = Yn, r;
  }
  return e.create = function(n, r, s) {
    return new Ae(n, r, s);
  }, e.prototype.next = function(n) {
    this.isStopped || this._next(n);
  }, e.prototype.error = function(n) {
    this.isStopped || (this.isStopped = !0, this._error(n));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(n) {
    this.destination.next(n);
  }, e.prototype._error = function(n) {
    try {
      this.destination.error(n);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(Ie), zn = Function.prototype.bind;
function tt(t, e) {
  return zn.call(t, e);
}
var Hn = function() {
  function t(e) {
    this.partialObserver = e;
  }
  return t.prototype.next = function(e) {
    var n = this.partialObserver;
    if (n.next)
      try {
        n.next(e);
      } catch (r) {
        qe(r);
      }
  }, t.prototype.error = function(e) {
    var n = this.partialObserver;
    if (n.error)
      try {
        n.error(e);
      } catch (r) {
        qe(r);
      }
    else
      qe(e);
  }, t.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (n) {
        qe(n);
      }
  }, t;
}(), Ae = function(t) {
  ie(e, t);
  function e(n, r, s) {
    var i = t.call(this) || this, o;
    if (C(n) || !n)
      o = {
        next: n ?? void 0,
        error: r ?? void 0,
        complete: s ?? void 0
      };
    else {
      var a;
      i && kt.useDeprecatedNextContext ? (a = Object.create(n), a.unsubscribe = function() {
        return i.unsubscribe();
      }, o = {
        next: n.next && tt(n.next, a),
        error: n.error && tt(n.error, a),
        complete: n.complete && tt(n.complete, a)
      }) : o = n;
    }
    return i.destination = new Hn(o), i;
  }
  return e;
}(Pt);
function qe(t) {
  sn(t);
}
function Kn(t) {
  throw t;
}
var Yn = {
  closed: !0,
  next: ut,
  error: Kn,
  complete: ut
}, Rt = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function Xe(t) {
  return t;
}
function Gn(t) {
  return t.length === 0 ? Xe : t.length === 1 ? t[0] : function(n) {
    return t.reduce(function(r, s) {
      return s(r);
    }, n);
  };
}
var D = function() {
  function t(e) {
    e && (this._subscribe = e);
  }
  return t.prototype.lift = function(e) {
    var n = new t();
    return n.source = this, n.operator = e, n;
  }, t.prototype.subscribe = function(e, n, r) {
    var s = this, i = Xn(e) ? e : new Ae(e, n, r);
    return Be(function() {
      var o = s, a = o.operator, c = o.source;
      i.add(a ? a.call(i, c) : c ? s._subscribe(i) : s._trySubscribe(i));
    }), i;
  }, t.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (n) {
      e.error(n);
    }
  }, t.prototype.forEach = function(e, n) {
    var r = this;
    return n = Lt(n), new n(function(s, i) {
      var o = new Ae({
        next: function(a) {
          try {
            e(a);
          } catch (c) {
            i(c), o.unsubscribe();
          }
        },
        error: i,
        complete: s
      });
      r.subscribe(o);
    });
  }, t.prototype._subscribe = function(e) {
    var n;
    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(e);
  }, t.prototype[Rt] = function() {
    return this;
  }, t.prototype.pipe = function() {
    for (var e = [], n = 0; n < arguments.length; n++)
      e[n] = arguments[n];
    return Gn(e)(this);
  }, t.prototype.toPromise = function(e) {
    var n = this;
    return e = Lt(e), new e(function(r, s) {
      var i;
      n.subscribe(function(o) {
        return i = o;
      }, function(o) {
        return s(o);
      }, function() {
        return r(i);
      });
    });
  }, t.create = function(e) {
    return new t(e);
  }, t;
}();
function Lt(t) {
  var e;
  return (e = t ?? kt.Promise) !== null && e !== void 0 ? e : Promise;
}
function Jn(t) {
  return t && C(t.next) && C(t.error) && C(t.complete);
}
function Xn(t) {
  return t && t instanceof Pt || Jn(t) && rn(t);
}
function Qn(t) {
  return C(t == null ? void 0 : t.lift);
}
function W(t) {
  return function(e) {
    if (Qn(e))
      return e.lift(function(n) {
        try {
          return t(n, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function V(t, e, n, r, s) {
  return new er(t, e, n, r, s);
}
var er = function(t) {
  ie(e, t);
  function e(n, r, s, i, o, a) {
    var c = t.call(this, n) || this;
    return c.onFinalize = o, c.shouldUnsubscribe = a, c._next = r ? function(u) {
      try {
        r(u);
      } catch (l) {
        n.error(l);
      }
    } : t.prototype._next, c._error = i ? function(u) {
      try {
        i(u);
      } catch (l) {
        n.error(l);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._error, c._complete = s ? function() {
      try {
        s();
      } catch (u) {
        n.error(u);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._complete, c;
  }
  return e.prototype.unsubscribe = function() {
    var n;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var r = this.closed;
      t.prototype.unsubscribe.call(this), !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this));
    }
  }, e;
}(Pt), tr = At(function(t) {
  return function() {
    t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), ee = function(t) {
  ie(e, t);
  function e() {
    var n = t.call(this) || this;
    return n.closed = !1, n.currentObservers = null, n.observers = [], n.isStopped = !1, n.hasError = !1, n.thrownError = null, n;
  }
  return e.prototype.lift = function(n) {
    var r = new Zt(this, this);
    return r.operator = n, r;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new tr();
  }, e.prototype.next = function(n) {
    var r = this;
    Be(function() {
      var s, i;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var o = Ee(r.currentObservers), a = o.next(); !a.done; a = o.next()) {
            var c = a.value;
            c.next(n);
          }
        } catch (u) {
          s = { error: u };
        } finally {
          try {
            a && !a.done && (i = o.return) && i.call(o);
          } finally {
            if (s)
              throw s.error;
          }
        }
      }
    });
  }, e.prototype.error = function(n) {
    var r = this;
    Be(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = !0, r.thrownError = n;
        for (var s = r.observers; s.length; )
          s.shift().error(n);
      }
    });
  }, e.prototype.complete = function() {
    var n = this;
    Be(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.isStopped = !0;
        for (var r = n.observers; r.length; )
          r.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var n;
      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(n) {
    return this._throwIfClosed(), t.prototype._trySubscribe.call(this, n);
  }, e.prototype._subscribe = function(n) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);
  }, e.prototype._innerSubscribe = function(n) {
    var r = this, s = this, i = s.hasError, o = s.isStopped, a = s.observers;
    return i || o ? nn : (this.currentObservers = null, a.push(n), new Ie(function() {
      r.currentObservers = null, Ve(a, n);
    }));
  }, e.prototype._checkFinalizedStatuses = function(n) {
    var r = this, s = r.hasError, i = r.thrownError, o = r.isStopped;
    s ? n.error(i) : o && n.complete();
  }, e.prototype.asObservable = function() {
    var n = new D();
    return n.source = this, n;
  }, e.create = function(n, r) {
    return new Zt(n, r);
  }, e;
}(D), Zt = function(t) {
  ie(e, t);
  function e(n, r) {
    var s = t.call(this) || this;
    return s.destination = n, s.source = r, s;
  }
  return e.prototype.next = function(n) {
    var r, s;
    (s = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || s === void 0 || s.call(r, n);
  }, e.prototype.error = function(n) {
    var r, s;
    (s = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || s === void 0 || s.call(r, n);
  }, e.prototype.complete = function() {
    var n, r;
    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);
  }, e.prototype._subscribe = function(n) {
    var r, s;
    return (s = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && s !== void 0 ? s : nn;
  }, e;
}(ee), on = {
  now: function() {
    return (on.delegate || Date).now();
  },
  delegate: void 0
}, nr = function(t) {
  ie(e, t);
  function e(n, r) {
    return t.call(this) || this;
  }
  return e.prototype.schedule = function(n, r) {
    return this;
  }, e;
}(Ie), Fe = {
  setInterval: function(t, e) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var s = Fe.delegate;
    return s != null && s.setInterval ? s.setInterval.apply(s, ye([t, e], me(n))) : setInterval.apply(void 0, ye([t, e], me(n)));
  },
  clearInterval: function(t) {
    var e = Fe.delegate;
    return ((e == null ? void 0 : e.clearInterval) || clearInterval)(t);
  },
  delegate: void 0
}, rr = function(t) {
  ie(e, t);
  function e(n, r) {
    var s = t.call(this, n, r) || this;
    return s.scheduler = n, s.work = r, s.pending = !1, s;
  }
  return e.prototype.schedule = function(n, r) {
    var s;
    if (r === void 0 && (r = 0), this.closed)
      return this;
    this.state = n;
    var i = this.id, o = this.scheduler;
    return i != null && (this.id = this.recycleAsyncId(o, i, r)), this.pending = !0, this.delay = r, this.id = (s = this.id) !== null && s !== void 0 ? s : this.requestAsyncId(o, this.id, r), this;
  }, e.prototype.requestAsyncId = function(n, r, s) {
    return s === void 0 && (s = 0), Fe.setInterval(n.flush.bind(n, this), s);
  }, e.prototype.recycleAsyncId = function(n, r, s) {
    if (s === void 0 && (s = 0), s != null && this.delay === s && this.pending === !1)
      return r;
    r != null && Fe.clearInterval(r);
  }, e.prototype.execute = function(n, r) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var s = this._execute(n, r);
    if (s)
      return s;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, e.prototype._execute = function(n, r) {
    var s = !1, i;
    try {
      this.work(n);
    } catch (o) {
      s = !0, i = o || new Error("Scheduled action threw falsy error");
    }
    if (s)
      return this.unsubscribe(), i;
  }, e.prototype.unsubscribe = function() {
    if (!this.closed) {
      var n = this, r = n.id, s = n.scheduler, i = s.actions;
      this.work = this.state = this.scheduler = null, this.pending = !1, Ve(i, this), r != null && (this.id = this.recycleAsyncId(s, r, null)), this.delay = null, t.prototype.unsubscribe.call(this);
    }
  }, e;
}(nr), Ut = function() {
  function t(e, n) {
    n === void 0 && (n = t.now), this.schedulerActionCtor = e, this.now = n;
  }
  return t.prototype.schedule = function(e, n, r) {
    return n === void 0 && (n = 0), new this.schedulerActionCtor(this, e).schedule(r, n);
  }, t.now = on.now, t;
}(), sr = function(t) {
  ie(e, t);
  function e(n, r) {
    r === void 0 && (r = Ut.now);
    var s = t.call(this, n, r) || this;
    return s.actions = [], s._active = !1, s;
  }
  return e.prototype.flush = function(n) {
    var r = this.actions;
    if (this._active) {
      r.push(n);
      return;
    }
    var s;
    this._active = !0;
    do
      if (s = n.execute(n.state, n.delay))
        break;
    while (n = r.shift());
    if (this._active = !1, s) {
      for (; n = r.shift(); )
        n.unsubscribe();
      throw s;
    }
  }, e;
}(Ut), ir = new sr(rr), or = ir, an = new D(function(t) {
  return t.complete();
});
function un(t) {
  return t && C(t.schedule);
}
function cn(t) {
  return t[t.length - 1];
}
function ln(t) {
  return un(cn(t)) ? t.pop() : void 0;
}
function ar(t, e) {
  return typeof cn(t) == "number" ? t.pop() : e;
}
var dn = function(t) {
  return t && typeof t.length == "number" && typeof t != "function";
};
function fn(t) {
  return C(t == null ? void 0 : t.then);
}
function hn(t) {
  return C(t[Rt]);
}
function pn(t) {
  return Symbol.asyncIterator && C(t == null ? void 0 : t[Symbol.asyncIterator]);
}
function mn(t) {
  return new TypeError("You provided " + (t !== null && typeof t == "object" ? "an invalid object" : "'" + t + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function ur() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var yn = ur();
function vn(t) {
  return C(t == null ? void 0 : t[yn]);
}
function gn(t) {
  return Vn(this, arguments, function() {
    var n, r, s, i;
    return tn(this, function(o) {
      switch (o.label) {
        case 0:
          n = t.getReader(), o.label = 1;
        case 1:
          o.trys.push([1, , 9, 10]), o.label = 2;
        case 2:
          return [4, xe(n.read())];
        case 3:
          return r = o.sent(), s = r.value, i = r.done, i ? [4, xe(void 0)] : [3, 5];
        case 4:
          return [2, o.sent()];
        case 5:
          return [4, xe(s)];
        case 6:
          return [4, o.sent()];
        case 7:
          return o.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return n.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function _n(t) {
  return C(t == null ? void 0 : t.getReader);
}
function oe(t) {
  if (t instanceof D)
    return t;
  if (t != null) {
    if (hn(t))
      return cr(t);
    if (dn(t))
      return lr(t);
    if (fn(t))
      return dr(t);
    if (pn(t))
      return wn(t);
    if (vn(t))
      return fr(t);
    if (_n(t))
      return hr(t);
  }
  throw mn(t);
}
function cr(t) {
  return new D(function(e) {
    var n = t[Rt]();
    if (C(n.subscribe))
      return n.subscribe(e);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function lr(t) {
  return new D(function(e) {
    for (var n = 0; n < t.length && !e.closed; n++)
      e.next(t[n]);
    e.complete();
  });
}
function dr(t) {
  return new D(function(e) {
    t.then(function(n) {
      e.closed || (e.next(n), e.complete());
    }, function(n) {
      return e.error(n);
    }).then(null, sn);
  });
}
function fr(t) {
  return new D(function(e) {
    var n, r;
    try {
      for (var s = Ee(t), i = s.next(); !i.done; i = s.next()) {
        var o = i.value;
        if (e.next(o), e.closed)
          return;
      }
    } catch (a) {
      n = { error: a };
    } finally {
      try {
        i && !i.done && (r = s.return) && r.call(s);
      } finally {
        if (n)
          throw n.error;
      }
    }
    e.complete();
  });
}
function wn(t) {
  return new D(function(e) {
    pr(t, e).catch(function(n) {
      return e.error(n);
    });
  });
}
function hr(t) {
  return wn(gn(t));
}
function pr(t, e) {
  var n, r, s, i;
  return Bn(this, void 0, void 0, function() {
    var o, a;
    return tn(this, function(c) {
      switch (c.label) {
        case 0:
          c.trys.push([0, 5, 6, 11]), n = Fn(t), c.label = 1;
        case 1:
          return [4, n.next()];
        case 2:
          if (r = c.sent(), !!r.done)
            return [3, 4];
          if (o = r.value, e.next(o), e.closed)
            return [2];
          c.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return a = c.sent(), s = { error: a }, [3, 11];
        case 6:
          return c.trys.push([6, , 9, 10]), r && !r.done && (i = n.return) ? [4, i.call(n)] : [3, 8];
        case 7:
          c.sent(), c.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (s)
            throw s.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
function te(t, e, n, r, s) {
  r === void 0 && (r = 0), s === void 0 && (s = !1);
  var i = e.schedule(function() {
    n(), s ? t.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if (t.add(i), !s)
    return i;
}
function bn(t, e) {
  return e === void 0 && (e = 0), W(function(n, r) {
    n.subscribe(V(r, function(s) {
      return te(r, t, function() {
        return r.next(s);
      }, e);
    }, function() {
      return te(r, t, function() {
        return r.complete();
      }, e);
    }, function(s) {
      return te(r, t, function() {
        return r.error(s);
      }, e);
    }));
  });
}
function Tn(t, e) {
  return e === void 0 && (e = 0), W(function(n, r) {
    r.add(t.schedule(function() {
      return n.subscribe(r);
    }, e));
  });
}
function mr(t, e) {
  return oe(t).pipe(Tn(e), bn(e));
}
function yr(t, e) {
  return oe(t).pipe(Tn(e), bn(e));
}
function vr(t, e) {
  return new D(function(n) {
    var r = 0;
    return e.schedule(function() {
      r === t.length ? n.complete() : (n.next(t[r++]), n.closed || this.schedule());
    });
  });
}
function gr(t, e) {
  return new D(function(n) {
    var r;
    return te(n, e, function() {
      r = t[yn](), te(n, e, function() {
        var s, i, o;
        try {
          s = r.next(), i = s.value, o = s.done;
        } catch (a) {
          n.error(a);
          return;
        }
        o ? n.complete() : n.next(i);
      }, 0, !0);
    }), function() {
      return C(r == null ? void 0 : r.return) && r.return();
    };
  });
}
function xn(t, e) {
  if (!t)
    throw new Error("Iterable cannot be null");
  return new D(function(n) {
    te(n, e, function() {
      var r = t[Symbol.asyncIterator]();
      te(n, e, function() {
        r.next().then(function(s) {
          s.done ? n.complete() : n.next(s.value);
        });
      }, 0, !0);
    });
  });
}
function _r(t, e) {
  return xn(gn(t), e);
}
function wr(t, e) {
  if (t != null) {
    if (hn(t))
      return mr(t, e);
    if (dn(t))
      return vr(t, e);
    if (fn(t))
      return yr(t, e);
    if (pn(t))
      return xn(t, e);
    if (vn(t))
      return gr(t, e);
    if (_n(t))
      return _r(t, e);
  }
  throw mn(t);
}
function Sn(t, e) {
  return e ? wr(t, e) : oe(t);
}
function br() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var n = ln(t);
  return Sn(t, n);
}
var It = At(function(t) {
  return function() {
    t(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function Tr(t, e) {
  var n = typeof e == "object";
  return new Promise(function(r, s) {
    var i = new Ae({
      next: function(o) {
        r(o), i.unsubscribe();
      },
      error: s,
      complete: function() {
        n ? r(e.defaultValue) : s(new It());
      }
    });
    t.subscribe(i);
  });
}
function xr(t) {
  return t instanceof Date && !isNaN(t);
}
function Ne(t, e) {
  return W(function(n, r) {
    var s = 0;
    n.subscribe(V(r, function(i) {
      r.next(t.call(e, i, s++));
    }));
  });
}
function Sr(t, e, n, r, s, i, o, a) {
  var c = [], u = 0, l = 0, _ = !1, m = function() {
    _ && !c.length && !u && e.complete();
  }, b = function(p) {
    return u < r ? $(p) : c.push(p);
  }, $ = function(p) {
    i && e.next(p), u++;
    var A = !1;
    oe(n(p, l++)).subscribe(V(e, function(k) {
      s == null || s(k), i ? b(k) : e.next(k);
    }, function() {
      A = !0;
    }, void 0, function() {
      if (A)
        try {
          u--;
          for (var k = function() {
            var T = c.shift();
            o ? te(e, o, function() {
              return $(T);
            }) : $(T);
          }; c.length && u < r; )
            k();
          m();
        } catch (T) {
          e.error(T);
        }
    }));
  };
  return t.subscribe(V(e, b, function() {
    _ = !0, m();
  })), function() {
    a == null || a();
  };
}
function On(t, e, n) {
  return n === void 0 && (n = 1 / 0), C(e) ? On(function(r, s) {
    return Ne(function(i, o) {
      return e(r, i, s, o);
    })(oe(t(r, s)));
  }, n) : (typeof e == "number" && (n = e), W(function(r, s) {
    return Sr(r, s, t, n);
  }));
}
function Or(t) {
  return t === void 0 && (t = 1 / 0), On(Xe, t);
}
function Er(t, e, n) {
  t === void 0 && (t = 0), n === void 0 && (n = or);
  var r = -1;
  return e != null && (un(e) ? n = e : r = e), new D(function(s) {
    var i = xr(t) ? +t - n.now() : t;
    i < 0 && (i = 0);
    var o = 0;
    return n.schedule(function() {
      s.closed || (s.next(o++), 0 <= r ? this.schedule(void 0, r) : s.complete());
    }, i);
  });
}
function nt() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var n = ln(t), r = ar(t, 1 / 0), s = t;
  return s.length ? s.length === 1 ? oe(s[0]) : Or(r)(Sn(s, n)) : an;
}
function je(t, e) {
  return W(function(n, r) {
    var s = 0;
    n.subscribe(V(r, function(i) {
      return t.call(e, i, s++) && r.next(i);
    }));
  });
}
function Ar(t) {
  return W(function(e, n) {
    var r = !1;
    e.subscribe(V(n, function(s) {
      r = !0, n.next(s);
    }, function() {
      r || n.next(t), n.complete();
    }));
  });
}
function kr(t) {
  return t <= 0 ? function() {
    return an;
  } : W(function(e, n) {
    var r = 0;
    e.subscribe(V(n, function(s) {
      ++r <= t && (n.next(s), t <= r && n.complete());
    }));
  });
}
function Pr(t) {
  return t === void 0 && (t = Rr), W(function(e, n) {
    var r = !1;
    e.subscribe(V(n, function(s) {
      r = !0, n.next(s);
    }, function() {
      return r ? n.complete() : n.error(t());
    }));
  });
}
function Rr() {
  return new It();
}
function Dt(t, e) {
  var n = arguments.length >= 2;
  return function(r) {
    return r.pipe(t ? je(function(s, i) {
      return t(s, i, r);
    }) : Xe, kr(1), n ? Ar(e) : Pr(function() {
      return new It();
    }));
  };
}
function En(t) {
  t === void 0 && (t = {});
  var e = t.connector, n = e === void 0 ? function() {
    return new ee();
  } : e, r = t.resetOnError, s = r === void 0 ? !0 : r, i = t.resetOnComplete, o = i === void 0 ? !0 : i, a = t.resetOnRefCountZero, c = a === void 0 ? !0 : a;
  return function(u) {
    var l, _, m, b = 0, $ = !1, p = !1, A = function() {
      _ == null || _.unsubscribe(), _ = void 0;
    }, k = function() {
      A(), l = m = void 0, $ = p = !1;
    }, T = function() {
      var X = l;
      k(), X == null || X.unsubscribe();
    };
    return W(function(X, j) {
      b++, !p && !$ && A();
      var ge = m = m ?? n();
      j.add(function() {
        b--, b === 0 && !p && !$ && (_ = rt(T, c));
      }), ge.subscribe(j), !l && b > 0 && (l = new Ae({
        next: function(ae) {
          return ge.next(ae);
        },
        error: function(ae) {
          p = !0, A(), _ = rt(k, s, ae), ge.error(ae);
        },
        complete: function() {
          $ = !0, A(), _ = rt(k, o), ge.complete();
        }
      }), oe(X).subscribe(l));
    })(u);
  };
}
function rt(t, e) {
  for (var n = [], r = 2; r < arguments.length; r++)
    n[r - 2] = arguments[r];
  if (e === !0) {
    t();
    return;
  }
  if (e !== !1) {
    var s = new Ae({
      next: function() {
        s.unsubscribe(), t();
      }
    });
    return e.apply(void 0, ye([], me(n))).subscribe(s);
  }
}
function Ir(t) {
  return W(function(e, n) {
    oe(t).subscribe(V(n, function() {
      return n.complete();
    }, ut)), !n.closed && e.subscribe(n);
  });
}
function Se(t, e, n) {
  var r = C(t) || e || n ? { next: t, error: e, complete: n } : t;
  return r ? W(function(s, i) {
    var o;
    (o = r.subscribe) === null || o === void 0 || o.call(r);
    var a = !0;
    s.subscribe(V(i, function(c) {
      var u;
      (u = r.next) === null || u === void 0 || u.call(r, c), i.next(c);
    }, function() {
      var c;
      a = !1, (c = r.complete) === null || c === void 0 || c.call(r), i.complete();
    }, function(c) {
      var u;
      a = !1, (u = r.error) === null || u === void 0 || u.call(r, c), i.error(c);
    }, function() {
      var c, u;
      a && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (u = r.finalize) === null || u === void 0 || u.call(r);
    }));
  }) : Xe;
}
const Cr = () => ({
  outgoingMessageSubject: new ee(),
  incomingMessageSubject: new ee(),
  responseSubject: new ee(),
  messageLifeCycleEventSubject: new ee(),
  dispatchEventSubject: new ee()
}), ct = {
  outgoingMessage: "radix#chromeExtension#send",
  incomingMessage: "radix#chromeExtension#receive"
}, $r = (t) => t.outgoingMessageSubject.pipe(
  Ne((e) => ({
    event: ct.outgoingMessage,
    payload: e
  })),
  Se((e) => {
    t.dispatchEventSubject.next(e);
  }),
  En()
);
var $e = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, An = { exports: {} };
(function(t) {
  (function(e, n) {
    t.exports ? t.exports = n() : e.log = n();
  })($e, function() {
    var e = function() {
    }, n = "undefined", r = typeof window !== n && typeof window.navigator !== n && /Trident\/|MSIE /.test(window.navigator.userAgent), s = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ];
    function i(p, A) {
      var k = p[A];
      if (typeof k.bind == "function")
        return k.bind(p);
      try {
        return Function.prototype.bind.call(k, p);
      } catch {
        return function() {
          return Function.prototype.apply.apply(k, [p, arguments]);
        };
      }
    }
    function o() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function a(p) {
      return p === "debug" && (p = "log"), typeof console === n ? !1 : p === "trace" && r ? o : console[p] !== void 0 ? i(console, p) : console.log !== void 0 ? i(console, "log") : e;
    }
    function c(p, A) {
      for (var k = 0; k < s.length; k++) {
        var T = s[k];
        this[T] = k < p ? e : this.methodFactory(T, p, A);
      }
      this.log = this.debug;
    }
    function u(p, A, k) {
      return function() {
        typeof console !== n && (c.call(this, A, k), this[p].apply(this, arguments));
      };
    }
    function l(p, A, k) {
      return a(p) || u.apply(this, arguments);
    }
    function _(p, A, k) {
      var T = this, X;
      A = A ?? "WARN";
      var j = "loglevel";
      typeof p == "string" ? j += ":" + p : typeof p == "symbol" && (j = void 0);
      function ge(O) {
        var ue = (s[O] || "silent").toUpperCase();
        if (!(typeof window === n || !j)) {
          try {
            window.localStorage[j] = ue;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(j) + "=" + ue + ";";
          } catch {
          }
        }
      }
      function ae() {
        var O;
        if (!(typeof window === n || !j)) {
          try {
            O = window.localStorage[j];
          } catch {
          }
          if (typeof O === n)
            try {
              var ue = window.document.cookie, De = ue.indexOf(
                encodeURIComponent(j) + "="
              );
              De !== -1 && (O = /^([^;]+)/.exec(ue.slice(De))[1]);
            } catch {
            }
          return T.levels[O] === void 0 && (O = void 0), O;
        }
      }
      function Un() {
        if (!(typeof window === n || !j)) {
          try {
            window.localStorage.removeItem(j);
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(j) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      T.name = p, T.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, T.methodFactory = k || l, T.getLevel = function() {
        return X;
      }, T.setLevel = function(O, ue) {
        if (typeof O == "string" && T.levels[O.toUpperCase()] !== void 0 && (O = T.levels[O.toUpperCase()]), typeof O == "number" && O >= 0 && O <= T.levels.SILENT) {
          if (X = O, ue !== !1 && ge(O), c.call(T, O, p), typeof console === n && O < T.levels.SILENT)
            return "No console available for logging";
        } else
          throw "log.setLevel() called with invalid level: " + O;
      }, T.setDefaultLevel = function(O) {
        A = O, ae() || T.setLevel(O, !1);
      }, T.resetLevel = function() {
        T.setLevel(A, !1), Un();
      }, T.enableAll = function(O) {
        T.setLevel(T.levels.TRACE, O);
      }, T.disableAll = function(O) {
        T.setLevel(T.levels.SILENT, O);
      };
      var Qe = ae();
      Qe == null && (Qe = A), T.setLevel(Qe, !1);
    }
    var m = new _(), b = {};
    m.getLogger = function(A) {
      if (typeof A != "symbol" && typeof A != "string" || A === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var k = b[A];
      return k || (k = b[A] = new _(
        A,
        m.getLevel(),
        m.methodFactory
      )), k;
    };
    var $ = typeof window !== n ? window.log : void 0;
    return m.noConflict = function() {
      return typeof window !== n && window.log === m && (window.log = $), m;
    }, m.getLoggers = function() {
      return b;
    }, m.default = m, m;
  });
})(An);
const H = An.exports, Nr = (t) => t.incomingMessageSubject.pipe(
  Se((e) => {
    "eventType" in e ? (H.debug(
      `ðŸ”µðŸ’¬â¬‡ï¸ message lifecycle event
${JSON.stringify(e, null, 2)}`
    ), t.messageLifeCycleEventSubject.next(e)) : (H.debug(`ðŸ”µâ¬‡ï¸ wallet response
${JSON.stringify(e, null, 2)}`), t.responseSubject.next(e));
  })
), jr = (t) => t.dispatchEventSubject.pipe(
  Se(({ event: e, payload: n }) => {
    H.debug(`ðŸ”µâ¬†ï¸ wallet request
${JSON.stringify(n, null, 2)}`), window.dispatchEvent(
      new CustomEvent(e, {
        detail: n
      })
    );
  })
), Mr = (t) => {
  const e = new Ie();
  return e.add(jr(t).subscribe()), e.add($r(t).subscribe()), e.add(Nr(t).subscribe()), e;
}, Lr = (t) => {
  const e = (r) => {
    const s = r.detail;
    t.incomingMessageSubject.next(s);
  };
  return addEventListener(ct.incomingMessage, e), { destroy: () => {
    removeEventListener(ct.incomingMessage, e);
  } };
}, Zr = (t = Cr()) => {
  const e = Mr(t), n = Lr(t);
  return { destroy: () => {
    n.destroy(), e.unsubscribe();
  }, subjects: t };
};
function st(t, e, n, r) {
  function s(i) {
    return i instanceof n ? i : new n(function(o) {
      o(i);
    });
  }
  return new (n || (n = Promise))(function(i, o) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (_) {
        o(_);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (_) {
        o(_);
      }
    }
    function u(l) {
      l.done ? i(l.value) : s(l.value).then(a, c);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function it(t, e) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, s && (i = u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, u[1])).done)
          return i;
        switch (s = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
          case 0:
          case 1:
            i = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < i[1]) {
              n.label = i[1], i = u;
              break;
            }
            if (i && n.label < i[2]) {
              n.label = i[2], n.ops.push(u);
              break;
            }
            i[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = e.call(t, n);
      } catch (l) {
        u = [6, l], s = 0;
      } finally {
        r = i = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function ze(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), s, i = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(s = r.next()).done; )
      i.push(s.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return i;
}
function he(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, s = e.length, i; r < s; r++)
      (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)), i[r] = e[r]);
  return t.concat(i || Array.prototype.slice.call(e));
}
var Ur = {
  withStackTrace: !1
}, kn = function(t, e, n) {
  n === void 0 && (n = Ur);
  var r = e.isOk() ? { type: "Ok", value: e.value } : { type: "Err", value: e.error }, s = n.withStackTrace ? new Error().stack : void 0;
  return {
    data: r,
    message: t,
    stack: s
  };
}, J = function() {
  function t(e) {
    this._promise = e;
  }
  return t.fromSafePromise = function(e) {
    var n = e.then(function(r) {
      return new le(r);
    });
    return new t(n);
  }, t.fromPromise = function(e, n) {
    var r = e.then(function(s) {
      return new le(s);
    }).catch(function(s) {
      return new de(n(s));
    });
    return new t(r);
  }, t.combine = function(e) {
    return Wr(e);
  }, t.combineWithAllErrors = function(e) {
    return qr(e);
  }, t.prototype.map = function(e) {
    var n = this;
    return new t(this._promise.then(function(r) {
      return st(n, void 0, void 0, function() {
        var s;
        return it(this, function(i) {
          switch (i.label) {
            case 0:
              return r.isErr() ? [2, new de(r.error)] : (s = le.bind, [4, e(r.value)]);
            case 1:
              return [2, new (s.apply(le, [void 0, i.sent()]))()];
          }
        });
      });
    }));
  }, t.prototype.mapErr = function(e) {
    var n = this;
    return new t(this._promise.then(function(r) {
      return st(n, void 0, void 0, function() {
        var s;
        return it(this, function(i) {
          switch (i.label) {
            case 0:
              return r.isOk() ? [2, new le(r.value)] : (s = de.bind, [4, e(r.error)]);
            case 1:
              return [2, new (s.apply(de, [void 0, i.sent()]))()];
          }
        });
      });
    }));
  }, t.prototype.andThen = function(e) {
    return new t(this._promise.then(function(n) {
      if (n.isErr())
        return new de(n.error);
      var r = e(n.value);
      return r instanceof t ? r._promise : r;
    }));
  }, t.prototype.orElse = function(e) {
    var n = this;
    return new t(this._promise.then(function(r) {
      return st(n, void 0, void 0, function() {
        return it(this, function(s) {
          return r.isErr() ? [2, e(r.error)] : [2, new le(r.value)];
        });
      });
    }));
  }, t.prototype.match = function(e, n) {
    return this._promise.then(function(r) {
      return r.match(e, n);
    });
  }, t.prototype.unwrapOr = function(e) {
    return this._promise.then(function(n) {
      return n.unwrapOr(e);
    });
  }, t.prototype.then = function(e, n) {
    return this._promise.then(e, n);
  }, t;
}(), Wt = function(t) {
  return new J(Promise.resolve(new de(t)));
};
J.fromPromise;
J.fromSafePromise;
var Dr = function(t) {
  return function(e) {
    return he(he([], ze(e), !1), [t], !1);
  };
}, Pn = function(t) {
  return t.reduce(function(e, n) {
    return e.isOk() ? n.isErr() ? B(n.error) : e.map(Dr(n.value)) : e;
  }, q([]));
}, Wr = function(t) {
  return J.fromSafePromise(Promise.all(t)).andThen(Pn);
}, Rn = function(t) {
  return t.reduce(function(e, n) {
    return n.isErr() ? e.isErr() ? B(he(he([], ze(e.error), !1), [n.error], !1)) : B([n.error]) : e.isErr() ? e : q(he(he([], ze(e.value), !1), [n.value], !1));
  }, q([]));
}, qr = function(t) {
  return J.fromSafePromise(Promise.all(t)).andThen(Rn);
}, lt;
(function(t) {
  function e(s, i) {
    return function() {
      for (var o = [], a = 0; a < arguments.length; a++)
        o[a] = arguments[a];
      try {
        var c = s.apply(void 0, he([], ze(o), !1));
        return q(c);
      } catch (u) {
        return B(i ? i(u) : u);
      }
    };
  }
  t.fromThrowable = e;
  function n(s) {
    return Pn(s);
  }
  t.combine = n;
  function r(s) {
    return Rn(s);
  }
  t.combineWithAllErrors = r;
})(lt || (lt = {}));
var q = function(t) {
  return new le(t);
}, B = function(t) {
  return new de(t);
}, le = function() {
  function t(e) {
    this.value = e;
  }
  return t.prototype.isOk = function() {
    return !0;
  }, t.prototype.isErr = function() {
    return !this.isOk();
  }, t.prototype.map = function(e) {
    return q(e(this.value));
  }, t.prototype.mapErr = function(e) {
    return q(this.value);
  }, t.prototype.andThen = function(e) {
    return e(this.value);
  }, t.prototype.orElse = function(e) {
    return q(this.value);
  }, t.prototype.asyncAndThen = function(e) {
    return e(this.value);
  }, t.prototype.asyncMap = function(e) {
    return J.fromSafePromise(e(this.value));
  }, t.prototype.unwrapOr = function(e) {
    return this.value;
  }, t.prototype.match = function(e, n) {
    return e(this.value);
  }, t.prototype._unsafeUnwrap = function(e) {
    return this.value;
  }, t.prototype._unsafeUnwrapErr = function(e) {
    throw kn("Called `_unsafeUnwrapErr` on an Ok", this, e);
  }, t;
}(), de = function() {
  function t(e) {
    this.error = e;
  }
  return t.prototype.isOk = function() {
    return !1;
  }, t.prototype.isErr = function() {
    return !this.isOk();
  }, t.prototype.map = function(e) {
    return B(this.error);
  }, t.prototype.mapErr = function(e) {
    return B(e(this.error));
  }, t.prototype.andThen = function(e) {
    return B(this.error);
  }, t.prototype.orElse = function(e) {
    return e(this.error);
  }, t.prototype.asyncAndThen = function(e) {
    return Wt(this.error);
  }, t.prototype.asyncMap = function(e) {
    return Wt(this.error);
  }, t.prototype.unwrapOr = function(e) {
    return e;
  }, t.prototype.match = function(e, n) {
    return n(this.error);
  }, t.prototype._unsafeUnwrap = function(e) {
    throw kn("Called `_unsafeUnwrap` on an Err", this, e);
  }, t.prototype._unsafeUnwrapErr = function(e) {
    return this.error;
  }, t;
}();
lt.fromThrowable;
const In = {
  extensionDetectionTime: 100,
  logLevel: "info"
}, Br = (t) => t, pe = {
  rejectedByUser: "rejectedByUser",
  missingExtension: "missingExtension",
  canceledByUser: "canceledByUser",
  walletRequestValidation: "walletRequestValidation",
  walletResponseValidation: "walletResponseValidation",
  wrongNetwork: "wrongNetwork",
  failedToPrepareTransaction: "failedToPrepareTransaction",
  failedToCompileTransaction: "failedToCompileTransaction",
  failedToSignTransaction: "failedToSignTransaction",
  failedToSubmitTransaction: "failedToSubmitTransaction",
  failedToPollSubmittedTransaction: "failedToPollSubmittedTransaction",
  submittedTransactionWasDuplicate: "submittedTransactionWasDuplicate",
  submittedTransactionHasFailedTransactionStatus: "submittedTransactionHasFailedTransactionStatus",
  submittedTransactionHasRejectedTransactionStatus: "submittedTransactionHasRejectedTransactionStatus"
}, Vr = (/* @__PURE__ */ new Map()).set(pe.missingExtension, "extension could not be found").set(pe.rejectedByUser, "user rejected request").set(pe.canceledByUser, "user has canceled the request"), He = (t, e, n) => ({
  error: t,
  requestId: e,
  message: n || Vr.get(t) || ""
}), Fr = (t) => J.fromPromise(Tr(t), Br).andThen(
  (e) => e
), zr = (t, e) => t.messageLifeCycleEventSubject.pipe(
  je((n) => n.requestId === e)
), Hr = (t) => (e) => (n) => {
  const r = new ee();
  e.requestControl && e.requestControl({
    cancelRequest: () => (H.debug(
      `ðŸ”µâ¬†ï¸âŒ wallet request canceled
${JSON.stringify(
        n,
        null,
        2
      )}`
    ), r.next())
  });
  const s = r.asObservable().pipe(
    Ne(
      () => B(He(pe.canceledByUser, n.requestId))
    )
  ), i = t.responseSubject.pipe(
    je((b) => b.requestId === n.requestId),
    Ne(
      (b) => "items" in b ? q(b) : B(b)
    )
  ), o = nt(
    i,
    s
  ).pipe(Dt()), a = zr(t, n.requestId).pipe(
    Se((b) => {
      e.eventCallback && e.eventCallback(b.eventType);
    }),
    Ir(i),
    En()
  ), c = a.subscribe(), u = Er(In.extensionDetectionTime).pipe(
    Ne(
      () => B(He(pe.missingExtension, n.requestId))
    )
  ), l = nt(
    u,
    a
  ).pipe(
    Dt(),
    je((b) => !("eventType" in b))
  ), _ = br(!0).pipe(
    Se(() => {
      t.outgoingMessageSubject.next(n);
    }),
    je(() => !1)
  ), m = nt(
    o,
    l,
    _
  ).pipe(
    Se(() => {
      c.unsubscribe();
    })
  );
  return Fr(m);
};
var E;
(function(t) {
  t.assertEqual = (s) => s;
  function e(s) {
  }
  t.assertIs = e;
  function n(s) {
    throw new Error();
  }
  t.assertNever = n, t.arrayToEnum = (s) => {
    const i = {};
    for (const o of s)
      i[o] = o;
    return i;
  }, t.getValidEnumValues = (s) => {
    const i = t.objectKeys(s).filter((a) => typeof s[s[a]] != "number"), o = {};
    for (const a of i)
      o[a] = s[a];
    return t.objectValues(o);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(i) {
    return s[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const o in s)
      Object.prototype.hasOwnProperty.call(s, o) && i.push(o);
    return i;
  }, t.find = (s, i) => {
    for (const o of s)
      if (i(o))
        return o;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function r(s, i = " | ") {
    return s.map((o) => typeof o == "string" ? `'${o}'` : o).join(i);
  }
  t.joinValues = r, t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(E || (E = {}));
const f = E.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), fe = (t) => {
  switch (typeof t) {
    case "undefined":
      return f.undefined;
    case "string":
      return f.string;
    case "number":
      return isNaN(t) ? f.nan : f.number;
    case "boolean":
      return f.boolean;
    case "function":
      return f.function;
    case "bigint":
      return f.bigint;
    case "object":
      return Array.isArray(t) ? f.array : t === null ? f.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? f.promise : typeof Map < "u" && t instanceof Map ? f.map : typeof Set < "u" && t instanceof Set ? f.set : typeof Date < "u" && t instanceof Date ? f.date : f.object;
    default:
      return f.unknown;
  }
}, d = E.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of"
]);
class ne extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const n = e || function(i) {
      return i.message;
    }, r = { _errors: [] }, s = (i) => {
      for (const o of i.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(s);
        else if (o.code === "invalid_return_type")
          s(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          s(o.argumentsError);
        else if (o.path.length === 0)
          r._errors.push(n(o));
        else {
          let a = r, c = 0;
          for (; c < o.path.length; ) {
            const u = o.path[c];
            c === o.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(n(o))) : a[u] = a[u] || { _errors: [] }, a = a[u], c++;
          }
        }
    };
    return s(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, E.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (n) => n.message) {
    const n = {}, r = [];
    for (const s of this.issues)
      s.path.length > 0 ? (n[s.path[0]] = n[s.path[0]] || [], n[s.path[0]].push(e(s))) : r.push(e(s));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
ne.create = (t) => new ne(t);
const Ke = (t, e) => {
  let n;
  switch (t.code) {
    case d.invalid_type:
      t.received === f.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
      break;
    case d.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected, E.jsonStringifyReplacer)}`;
      break;
    case d.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${E.joinValues(t.keys, ", ")}`;
      break;
    case d.invalid_union:
      n = "Invalid input";
      break;
    case d.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${E.joinValues(t.options)}`;
      break;
    case d.invalid_enum_value:
      n = `Invalid enum value. Expected ${E.joinValues(t.options)}, received '${t.received}'`;
      break;
    case d.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case d.invalid_return_type:
      n = "Invalid function return type";
      break;
    case d.invalid_date:
      n = "Invalid date";
      break;
    case d.invalid_string:
      typeof t.validation == "object" ? "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : E.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
      break;
    case d.too_small:
      t.type === "array" ? n = `Array must contain ${t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be greater than ${t.inclusive ? "or equal to " : ""}${t.minimum}` : t.type === "date" ? n = `Date must be greater than ${t.inclusive ? "or equal to " : ""}${new Date(t.minimum)}` : n = "Invalid input";
      break;
    case d.too_big:
      t.type === "array" ? n = `Array must contain ${t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be less than ${t.inclusive ? "or equal to " : ""}${t.maximum}` : t.type === "date" ? n = `Date must be smaller than ${t.inclusive ? "or equal to " : ""}${new Date(t.maximum)}` : n = "Invalid input";
      break;
    case d.custom:
      n = "Invalid input";
      break;
    case d.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case d.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    default:
      n = e.defaultError, E.assertNever(t);
  }
  return { message: n };
};
let Kr = Ke;
function dt() {
  return Kr;
}
const ft = (t) => {
  const { data: e, path: n, errorMaps: r, issueData: s } = t, i = [...n, ...s.path || []], o = {
    ...s,
    path: i
  };
  let a = "";
  const c = r.filter((u) => !!u).slice().reverse();
  for (const u of c)
    a = u(o, { data: e, defaultError: a }).message;
  return {
    ...s,
    path: i,
    message: s.message || a
  };
};
function h(t, e) {
  const n = ft({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      dt(),
      Ke
    ].filter((r) => !!r)
  });
  t.common.issues.push(n);
}
class L {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, n) {
    const r = [];
    for (const s of n) {
      if (s.status === "aborted")
        return v;
      s.status === "dirty" && e.dirty(), r.push(s.value);
    }
    return { status: e.value, value: r };
  }
  static async mergeObjectAsync(e, n) {
    const r = [];
    for (const s of n)
      r.push({
        key: await s.key,
        value: await s.value
      });
    return L.mergeObjectSync(e, r);
  }
  static mergeObjectSync(e, n) {
    const r = {};
    for (const s of n) {
      const { key: i, value: o } = s;
      if (i.status === "aborted" || o.status === "aborted")
        return v;
      i.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), (typeof o.value < "u" || s.alwaysSet) && (r[i.value] = o.value);
    }
    return { status: e.value, value: r };
  }
}
const v = Object.freeze({
  status: "aborted"
}), Z = (t) => ({ status: "valid", value: t }), qt = (t) => t.status === "aborted", Bt = (t) => t.status === "dirty", ht = (t) => t.status === "valid", Vt = (t) => typeof Promise !== void 0 && t instanceof Promise;
var S;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(S || (S = {}));
class F {
  constructor(e, n, r, s) {
    this.parent = e, this.data = n, this._path = r, this._key = s;
  }
  get path() {
    return this._path.concat(this._key);
  }
}
const Ft = (t, e) => {
  if (ht(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return { success: !1, error: new ne(t.common.issues) };
};
function w(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: n, required_error: r, description: s } = t;
  if (e && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (o, a) => o.code !== "invalid_type" ? { message: a.defaultError } : typeof a.data > "u" ? { message: r ?? a.defaultError } : { message: n ?? a.defaultError }, description: s };
}
class x {
  constructor(e) {
    this.spa = this.safeParseAsync, this.superRefine = this._refinement, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.default = this.default.bind(this), this.describe = this.describe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return fe(e.data);
  }
  _getOrReturnCtx(e, n) {
    return n || {
      common: e.parent.common,
      data: e.data,
      parsedType: fe(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new L(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: fe(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (Vt(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n);
  }
  parse(e, n) {
    const r = this.safeParse(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(e, n) {
    var r;
    const s = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: fe(e)
    }, i = this._parseSync({ data: e, path: s.path, parent: s });
    return Ft(s, i);
  }
  async parseAsync(e, n) {
    const r = await this.safeParseAsync(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(e, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: fe(e)
    }, s = this._parse({ data: e, path: [], parent: r }), i = await (Vt(s) ? s : Promise.resolve(s));
    return Ft(r, i);
  }
  refine(e, n) {
    const r = (s) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(s) : n;
    return this._refinement((s, i) => {
      const o = e(s), a = () => i.addIssue({
        code: d.custom,
        ...r(s)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((c) => c ? !0 : (a(), !1)) : o ? !0 : (a(), !1);
    });
  }
  refinement(e, n) {
    return this._refinement((r, s) => e(r) ? !0 : (s.addIssue(typeof n == "function" ? n(r, s) : n), !1));
  }
  _refinement(e) {
    return new se({
      schema: this,
      typeName: y.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  optional() {
    return K.create(this);
  }
  nullable() {
    return Re.create(this);
  }
  nullish() {
    return this.optional().nullable();
  }
  array() {
    return Y.create(this);
  }
  promise() {
    return Ze.create(this);
  }
  or(e) {
    return Ye.create([this, e]);
  }
  and(e) {
    return Ge.create(this, e);
  }
  transform(e) {
    return new se({
      schema: this,
      typeName: y.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const n = typeof e == "function" ? e : () => e;
    return new $n({
      innerType: this,
      defaultValue: n,
      typeName: y.ZodDefault
    });
  }
  brand() {
    return new Qr({
      typeName: y.ZodBranded,
      type: this,
      ...w(void 0)
    });
  }
  describe(e) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: e
    });
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const Yr = /^c[^\s-]{8,}$/i, Gr = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, Jr = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
class ve extends x {
  constructor() {
    super(...arguments), this._regex = (e, n, r) => this.refinement((s) => e.test(s), {
      validation: n,
      code: d.invalid_string,
      ...S.errToObj(r)
    }), this.nonempty = (e) => this.min(1, S.errToObj(e)), this.trim = () => new ve({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  _parse(e) {
    if (this._getType(e) !== f.string) {
      const i = this._getOrReturnCtx(e);
      return h(
        i,
        {
          code: d.invalid_type,
          expected: f.string,
          received: i.parsedType
        }
      ), v;
    }
    const r = new L();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (s = this._getOrReturnCtx(e, s), h(s, {
          code: d.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          message: i.message
        }), r.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (s = this._getOrReturnCtx(e, s), h(s, {
          code: d.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          message: i.message
        }), r.dirty());
      else if (i.kind === "email")
        Jr.test(e.data) || (s = this._getOrReturnCtx(e, s), h(s, {
          validation: "email",
          code: d.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "uuid")
        Gr.test(e.data) || (s = this._getOrReturnCtx(e, s), h(s, {
          validation: "uuid",
          code: d.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid")
        Yr.test(e.data) || (s = this._getOrReturnCtx(e, s), h(s, {
          validation: "cuid",
          code: d.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), h(s, {
            validation: "url",
            code: d.invalid_string,
            message: i.message
          }), r.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), h(s, {
          validation: "regex",
          code: d.invalid_string,
          message: i.message
        }), r.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s), h(s, {
          code: d.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), r.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s), h(s, {
          code: d.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), r.dirty()) : E.assertNever(i);
    return { status: r.value, value: e.data };
  }
  _addCheck(e) {
    return new ve({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...S.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...S.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...S.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...S.errToObj(e) });
  }
  regex(e, n) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...S.errToObj(n)
    });
  }
  startsWith(e, n) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...S.errToObj(n)
    });
  }
  endsWith(e, n) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...S.errToObj(n)
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...S.errToObj(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...S.errToObj(n)
    });
  }
  length(e, n) {
    return this.min(e, n).max(e, n);
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
ve.create = (t) => new ve({
  checks: [],
  typeName: y.ZodString,
  ...w(t)
});
function Xr(t, e) {
  const n = (t.toString().split(".")[1] || "").length, r = (e.toString().split(".")[1] || "").length, s = n > r ? n : r, i = parseInt(t.toFixed(s).replace(".", "")), o = parseInt(e.toFixed(s).replace(".", ""));
  return i % o / Math.pow(10, s);
}
class ke extends x {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._getType(e) !== f.number) {
      const i = this._getOrReturnCtx(e);
      return h(i, {
        code: d.invalid_type,
        expected: f.number,
        received: i.parsedType
      }), v;
    }
    let r;
    const s = new L();
    for (const i of this._def.checks)
      i.kind === "int" ? E.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), h(r, {
        code: d.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r), h(r, {
        code: d.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r), h(r, {
        code: d.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? Xr(e.data, i.value) !== 0 && (r = this._getOrReturnCtx(e, r), h(r, {
        code: d.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : E.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, S.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, S.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, S.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, S.toString(n));
  }
  setLimit(e, n, r, s) {
    return new ke({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: r,
          message: S.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new ke({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: S.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: S.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: S.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: S.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: S.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: S.toString(n)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int");
  }
}
ke.create = (t) => new ke({
  checks: [],
  typeName: y.ZodNumber,
  ...w(t)
});
class pt extends x {
  _parse(e) {
    if (this._getType(e) !== f.bigint) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.bigint,
        received: r.parsedType
      }), v;
    }
    return Z(e.data);
  }
}
pt.create = (t) => new pt({
  typeName: y.ZodBigInt,
  ...w(t)
});
class mt extends x {
  _parse(e) {
    if (this._getType(e) !== f.boolean) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.boolean,
        received: r.parsedType
      }), v;
    }
    return Z(e.data);
  }
}
mt.create = (t) => new mt({
  typeName: y.ZodBoolean,
  ...w(t)
});
class Le extends x {
  _parse(e) {
    if (this._getType(e) !== f.date) {
      const i = this._getOrReturnCtx(e);
      return h(i, {
        code: d.invalid_type,
        expected: f.date,
        received: i.parsedType
      }), v;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return h(i, {
        code: d.invalid_date
      }), v;
    }
    const r = new L();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s), h(s, {
        code: d.too_small,
        message: i.message,
        inclusive: !0,
        minimum: i.value,
        type: "date"
      }), r.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s), h(s, {
        code: d.too_big,
        message: i.message,
        inclusive: !0,
        maximum: i.value,
        type: "date"
      }), r.dirty()) : E.assertNever(i);
    return {
      status: r.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Le({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: S.toString(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: S.toString(n)
    });
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
}
Le.create = (t) => new Le({
  checks: [],
  typeName: y.ZodDate,
  ...w(t)
});
class yt extends x {
  _parse(e) {
    if (this._getType(e) !== f.undefined) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.undefined,
        received: r.parsedType
      }), v;
    }
    return Z(e.data);
  }
}
yt.create = (t) => new yt({
  typeName: y.ZodUndefined,
  ...w(t)
});
class vt extends x {
  _parse(e) {
    if (this._getType(e) !== f.null) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.null,
        received: r.parsedType
      }), v;
    }
    return Z(e.data);
  }
}
vt.create = (t) => new vt({
  typeName: y.ZodNull,
  ...w(t)
});
class gt extends x {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return Z(e.data);
  }
}
gt.create = (t) => new gt({
  typeName: y.ZodAny,
  ...w(t)
});
class Oe extends x {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return Z(e.data);
  }
}
Oe.create = (t) => new Oe({
  typeName: y.ZodUnknown,
  ...w(t)
});
class re extends x {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return h(n, {
      code: d.invalid_type,
      expected: f.never,
      received: n.parsedType
    }), v;
  }
}
re.create = (t) => new re({
  typeName: y.ZodNever,
  ...w(t)
});
class _t extends x {
  _parse(e) {
    if (this._getType(e) !== f.undefined) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.void,
        received: r.parsedType
      }), v;
    }
    return Z(e.data);
  }
}
_t.create = (t) => new _t({
  typeName: y.ZodVoid,
  ...w(t)
});
class Y extends x {
  _parse(e) {
    const { ctx: n, status: r } = this._processInputParams(e), s = this._def;
    if (n.parsedType !== f.array)
      return h(n, {
        code: d.invalid_type,
        expected: f.array,
        received: n.parsedType
      }), v;
    if (s.minLength !== null && n.data.length < s.minLength.value && (h(n, {
      code: d.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      message: s.minLength.message
    }), r.dirty()), s.maxLength !== null && n.data.length > s.maxLength.value && (h(n, {
      code: d.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      message: s.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all(n.data.map((o, a) => s.type._parseAsync(new F(n, o, n.path, a)))).then((o) => L.mergeArray(r, o));
    const i = n.data.map((o, a) => s.type._parseSync(new F(n, o, n.path, a)));
    return L.mergeArray(r, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, n) {
    return new Y({
      ...this._def,
      minLength: { value: e, message: S.toString(n) }
    });
  }
  max(e, n) {
    return new Y({
      ...this._def,
      maxLength: { value: e, message: S.toString(n) }
    });
  }
  length(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Y.create = (t, e) => new Y({
  type: t,
  minLength: null,
  maxLength: null,
  typeName: y.ZodArray,
  ...w(e)
});
var wt;
(function(t) {
  t.mergeShapes = (e, n) => ({
    ...e,
    ...n
  });
})(wt || (wt = {}));
const zt = (t) => (e) => new I({
  ...t,
  shape: () => ({
    ...t.shape(),
    ...e
  })
});
function Te(t) {
  if (t instanceof I) {
    const e = {};
    for (const n in t.shape) {
      const r = t.shape[n];
      e[n] = K.create(Te(r));
    }
    return new I({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof Y ? Y.create(Te(t.element)) : t instanceof K ? K.create(Te(t.unwrap())) : t instanceof Re ? Re.create(Te(t.unwrap())) : t instanceof G ? G.create(t.items.map((e) => Te(e))) : t;
}
class I extends x {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = zt(this._def), this.extend = zt(this._def);
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), n = E.objectKeys(e);
    return this._cached = { shape: e, keys: n };
  }
  _parse(e) {
    if (this._getType(e) !== f.object) {
      const u = this._getOrReturnCtx(e);
      return h(u, {
        code: d.invalid_type,
        expected: f.object,
        received: u.parsedType
      }), v;
    }
    const { status: r, ctx: s } = this._processInputParams(e), { shape: i, keys: o } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof re && this._def.unknownKeys === "strip"))
      for (const u in s.data)
        o.includes(u) || a.push(u);
    const c = [];
    for (const u of o) {
      const l = i[u], _ = s.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: l._parse(new F(s, _, s.path, u)),
        alwaysSet: u in s.data
      });
    }
    if (this._def.catchall instanceof re) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of a)
          c.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: s.data[l] }
          });
      else if (u === "strict")
        a.length > 0 && (h(s, {
          code: d.unrecognized_keys,
          keys: a
        }), r.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of a) {
        const _ = s.data[l];
        c.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new F(s, _, s.path, l)
          ),
          alwaysSet: l in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of c) {
        const _ = await l.key;
        u.push({
          key: _,
          value: await l.value,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => L.mergeObjectSync(r, u)) : L.mergeObjectSync(r, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return S.errToObj, new I({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (n, r) => {
          var s, i, o, a;
          const c = (o = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (a = S.errToObj(e).message) !== null && a !== void 0 ? a : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new I({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new I({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  setKey(e, n) {
    return this.augment({ [e]: n });
  }
  merge(e) {
    return new I({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => wt.mergeShapes(this._def.shape(), e._def.shape()),
      typeName: y.ZodObject
    });
  }
  catchall(e) {
    return new I({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const n = {};
    return E.objectKeys(e).map((r) => {
      this.shape[r] && (n[r] = this.shape[r]);
    }), new I({
      ...this._def,
      shape: () => n
    });
  }
  omit(e) {
    const n = {};
    return E.objectKeys(this.shape).map((r) => {
      E.objectKeys(e).indexOf(r) === -1 && (n[r] = this.shape[r]);
    }), new I({
      ...this._def,
      shape: () => n
    });
  }
  deepPartial() {
    return Te(this);
  }
  partial(e) {
    const n = {};
    if (e)
      return E.objectKeys(this.shape).map((r) => {
        E.objectKeys(e).indexOf(r) === -1 ? n[r] = this.shape[r] : n[r] = this.shape[r].optional();
      }), new I({
        ...this._def,
        shape: () => n
      });
    for (const r in this.shape) {
      const s = this.shape[r];
      n[r] = s.optional();
    }
    return new I({
      ...this._def,
      shape: () => n
    });
  }
  required() {
    const e = {};
    for (const n in this.shape) {
      let s = this.shape[n];
      for (; s instanceof K; )
        s = s._def.innerType;
      e[n] = s;
    }
    return new I({
      ...this._def,
      shape: () => e
    });
  }
  keyof() {
    return Cn(E.objectKeys(this.shape));
  }
}
I.create = (t, e) => new I({
  shape: () => t,
  unknownKeys: "strip",
  catchall: re.create(),
  typeName: y.ZodObject,
  ...w(e)
});
I.strictCreate = (t, e) => new I({
  shape: () => t,
  unknownKeys: "strict",
  catchall: re.create(),
  typeName: y.ZodObject,
  ...w(e)
});
I.lazycreate = (t, e) => new I({
  shape: t,
  unknownKeys: "strip",
  catchall: re.create(),
  typeName: y.ZodObject,
  ...w(e)
});
class Ye extends x {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = this._def.options;
    function s(i) {
      for (const a of i)
        if (a.result.status === "valid")
          return a.result;
      for (const a of i)
        if (a.result.status === "dirty")
          return n.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((a) => new ne(a.ctx.common.issues));
      return h(n, {
        code: d.invalid_union,
        unionErrors: o
      }), v;
    }
    if (n.common.async)
      return Promise.all(r.map(async (i) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(s);
    {
      let i;
      const o = [];
      for (const c of r) {
        const u = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: n.data,
          path: n.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !i && (i = { result: l, ctx: u }), u.common.issues.length && o.push(u.common.issues);
      }
      if (i)
        return n.common.issues.push(...i.ctx.common.issues), i.result;
      const a = o.map((c) => new ne(c));
      return h(n, {
        code: d.invalid_union,
        unionErrors: a
      }), v;
    }
  }
  get options() {
    return this._def.options;
  }
}
Ye.create = (t, e) => new Ye({
  options: t,
  typeName: y.ZodUnion,
  ...w(e)
});
class Ct extends x {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.object)
      return h(n, {
        code: d.invalid_type,
        expected: f.object,
        received: n.parsedType
      }), v;
    const r = this.discriminator, s = n.data[r], i = this.options.get(s);
    return i ? n.common.async ? i._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : i._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (h(n, {
      code: d.invalid_union_discriminator,
      options: this.validDiscriminatorValues,
      path: [r]
    }), v);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get validDiscriminatorValues() {
    return Array.from(this.options.keys());
  }
  get options() {
    return this._def.options;
  }
  static create(e, n, r) {
    const s = /* @__PURE__ */ new Map();
    try {
      n.forEach((i) => {
        const o = i.shape[e].value;
        s.set(o, i);
      });
    } catch {
      throw new Error("The discriminator value could not be extracted from all the provided schemas");
    }
    if (s.size !== n.length)
      throw new Error("Some of the discriminator values are not unique");
    return new Ct({
      typeName: y.ZodDiscriminatedUnion,
      discriminator: e,
      options: s,
      ...w(r)
    });
  }
}
function bt(t, e) {
  const n = fe(t), r = fe(e);
  if (t === e)
    return { valid: !0, data: t };
  if (n === f.object && r === f.object) {
    const s = E.objectKeys(e), i = E.objectKeys(t).filter((a) => s.indexOf(a) !== -1), o = { ...t, ...e };
    for (const a of i) {
      const c = bt(t[a], e[a]);
      if (!c.valid)
        return { valid: !1 };
      o[a] = c.data;
    }
    return { valid: !0, data: o };
  } else if (n === f.array && r === f.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let i = 0; i < t.length; i++) {
      const o = t[i], a = e[i], c = bt(o, a);
      if (!c.valid)
        return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else
    return n === f.date && r === f.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class Ge extends x {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), s = (i, o) => {
      if (qt(i) || qt(o))
        return v;
      const a = bt(i.value, o.value);
      return a.valid ? ((Bt(i) || Bt(o)) && n.dirty(), { status: n.value, value: a.data }) : (h(r, {
        code: d.invalid_intersection_types
      }), v);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([i, o]) => s(i, o)) : s(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
Ge.create = (t, e, n) => new Ge({
  left: t,
  right: e,
  typeName: y.ZodIntersection,
  ...w(n)
});
class G extends x {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.array)
      return h(r, {
        code: d.invalid_type,
        expected: f.array,
        received: r.parsedType
      }), v;
    if (r.data.length < this._def.items.length)
      return h(r, {
        code: d.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        type: "array"
      }), v;
    !this._def.rest && r.data.length > this._def.items.length && (h(r, {
      code: d.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      type: "array"
    }), n.dirty());
    const i = r.data.map((o, a) => {
      const c = this._def.items[a] || this._def.rest;
      return c ? c._parse(new F(r, o, r.path, a)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(i).then((o) => L.mergeArray(n, o)) : L.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new G({
      ...this._def,
      rest: e
    });
  }
}
G.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new G({
    items: t,
    typeName: y.ZodTuple,
    rest: null,
    ...w(e)
  });
};
class Je extends x {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.object)
      return h(r, {
        code: d.invalid_type,
        expected: f.object,
        received: r.parsedType
      }), v;
    const s = [], i = this._def.keyType, o = this._def.valueType;
    for (const a in r.data)
      s.push({
        key: i._parse(new F(r, a, r.path, a)),
        value: o._parse(new F(r, r.data[a], r.path, a))
      });
    return r.common.async ? L.mergeObjectAsync(n, s) : L.mergeObjectSync(n, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, n, r) {
    return n instanceof x ? new Je({
      keyType: e,
      valueType: n,
      typeName: y.ZodRecord,
      ...w(r)
    }) : new Je({
      keyType: ve.create(),
      valueType: e,
      typeName: y.ZodRecord,
      ...w(n)
    });
  }
}
class Tt extends x {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.map)
      return h(r, {
        code: d.invalid_type,
        expected: f.map,
        received: r.parsedType
      }), v;
    const s = this._def.keyType, i = this._def.valueType, o = [...r.data.entries()].map(([a, c], u) => ({
      key: s._parse(new F(r, a, r.path, [u, "key"])),
      value: i._parse(new F(r, c, r.path, [u, "value"]))
    }));
    if (r.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of o) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return v;
          (u.status === "dirty" || l.status === "dirty") && n.dirty(), a.set(u.value, l.value);
        }
        return { status: n.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const c of o) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return v;
        (u.status === "dirty" || l.status === "dirty") && n.dirty(), a.set(u.value, l.value);
      }
      return { status: n.value, value: a };
    }
  }
}
Tt.create = (t, e, n) => new Tt({
  valueType: e,
  keyType: t,
  typeName: y.ZodMap,
  ...w(n)
});
class Pe extends x {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.set)
      return h(r, {
        code: d.invalid_type,
        expected: f.set,
        received: r.parsedType
      }), v;
    const s = this._def;
    s.minSize !== null && r.data.size < s.minSize.value && (h(r, {
      code: d.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      message: s.minSize.message
    }), n.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (h(r, {
      code: d.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      message: s.maxSize.message
    }), n.dirty());
    const i = this._def.valueType;
    function o(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return v;
        l.status === "dirty" && n.dirty(), u.add(l.value);
      }
      return { status: n.value, value: u };
    }
    const a = [...r.data.values()].map((c, u) => i._parse(new F(r, c, r.path, u)));
    return r.common.async ? Promise.all(a).then((c) => o(c)) : o(a);
  }
  min(e, n) {
    return new Pe({
      ...this._def,
      minSize: { value: e, message: S.toString(n) }
    });
  }
  max(e, n) {
    return new Pe({
      ...this._def,
      maxSize: { value: e, message: S.toString(n) }
    });
  }
  size(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Pe.create = (t, e) => new Pe({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: y.ZodSet,
  ...w(e)
});
class Me extends x {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.function)
      return h(n, {
        code: d.invalid_type,
        expected: f.function,
        received: n.parsedType
      }), v;
    function r(a, c) {
      return ft({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          dt(),
          Ke
        ].filter((u) => !!u),
        issueData: {
          code: d.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(a, c) {
      return ft({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          dt(),
          Ke
        ].filter((u) => !!u),
        issueData: {
          code: d.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: n.common.contextualErrorMap }, o = n.data;
    return this._def.returns instanceof Ze ? Z(async (...a) => {
      const c = new ne([]), u = await this._def.args.parseAsync(a, i).catch((m) => {
        throw c.addIssue(r(a, m)), c;
      }), l = await o(...u);
      return await this._def.returns._def.type.parseAsync(l, i).catch((m) => {
        throw c.addIssue(s(l, m)), c;
      });
    }) : Z((...a) => {
      const c = this._def.args.safeParse(a, i);
      if (!c.success)
        throw new ne([r(a, c.error)]);
      const u = o(...c.data), l = this._def.returns.safeParse(u, i);
      if (!l.success)
        throw new ne([s(u, l.error)]);
      return l.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new Me({
      ...this._def,
      args: G.create(e).rest(Oe.create())
    });
  }
  returns(e) {
    return new Me({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, n, r) {
    return new Me({
      args: e || G.create([]).rest(Oe.create()),
      returns: n || Oe.create(),
      typeName: y.ZodFunction,
      ...w(r)
    });
  }
}
class xt extends x {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
xt.create = (t, e) => new xt({
  getter: t,
  typeName: y.ZodLazy,
  ...w(e)
});
class St extends x {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return h(n, {
        code: d.invalid_literal,
        expected: this._def.value
      }), v;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
St.create = (t, e) => new St({
  value: t,
  typeName: y.ZodLiteral,
  ...w(e)
});
function Cn(t, e) {
  return new $t({
    values: t,
    typeName: y.ZodEnum,
    ...w(e)
  });
}
class $t extends x {
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return h(n, {
        expected: E.joinValues(r),
        received: n.parsedType,
        code: d.invalid_type
      }), v;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return h(n, {
        received: n.data,
        code: d.invalid_enum_value,
        options: r
      }), v;
    }
    return Z(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Values() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
}
$t.create = Cn;
class Ot extends x {
  _parse(e) {
    const n = E.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);
    if (r.parsedType !== f.string && r.parsedType !== f.number) {
      const s = E.objectValues(n);
      return h(r, {
        expected: E.joinValues(s),
        received: r.parsedType,
        code: d.invalid_type
      }), v;
    }
    if (n.indexOf(e.data) === -1) {
      const s = E.objectValues(n);
      return h(r, {
        received: r.data,
        code: d.invalid_enum_value,
        options: s
      }), v;
    }
    return Z(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
Ot.create = (t, e) => new Ot({
  values: t,
  typeName: y.ZodNativeEnum,
  ...w(e)
});
class Ze extends x {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.promise && n.common.async === !1)
      return h(n, {
        code: d.invalid_type,
        expected: f.promise,
        received: n.parsedType
      }), v;
    const r = n.parsedType === f.promise ? n.data : Promise.resolve(n.data);
    return Z(r.then((s) => this._def.type.parseAsync(s, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
Ze.create = (t, e) => new Ze({
  type: t,
  typeName: y.ZodPromise,
  ...w(e)
});
class se extends x {
  innerType() {
    return this._def.schema;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), s = this._def.effect || null;
    if (s.type === "preprocess") {
      const o = s.transform(r.data);
      return r.common.async ? Promise.resolve(o).then((a) => this._def.schema._parseAsync({
        data: a,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: o,
        path: r.path,
        parent: r
      });
    }
    const i = {
      addIssue: (o) => {
        h(r, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "refinement") {
      const o = (a) => {
        const c = s.refinement(a, i);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? v : (a.status === "dirty" && n.dirty(), o(a.value), { status: n.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) => a.status === "aborted" ? v : (a.status === "dirty" && n.dirty(), o(a.value).then(() => ({ status: n.value, value: a.value }))));
    }
    if (s.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!ht(o))
          return o;
        const a = s.transform(o.value, i);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => ht(o) ? Promise.resolve(s.transform(o.value, i)).then((a) => ({ status: n.value, value: a })) : o);
    E.assertNever(s);
  }
}
se.create = (t, e, n) => new se({
  schema: t,
  typeName: y.ZodEffects,
  effect: e,
  ...w(n)
});
se.createWithPreprocess = (t, e, n) => new se({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: y.ZodEffects,
  ...w(n)
});
class K extends x {
  _parse(e) {
    return this._getType(e) === f.undefined ? Z(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
K.create = (t, e) => new K({
  innerType: t,
  typeName: y.ZodOptional,
  ...w(e)
});
class Re extends x {
  _parse(e) {
    return this._getType(e) === f.null ? Z(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Re.create = (t, e) => new Re({
  innerType: t,
  typeName: y.ZodNullable,
  ...w(e)
});
class $n extends x {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    let r = n.data;
    return n.parsedType === f.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
$n.create = (t, e) => new K({
  innerType: t,
  typeName: y.ZodOptional,
  ...w(e)
});
class Et extends x {
  _parse(e) {
    if (this._getType(e) !== f.nan) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.nan,
        received: r.parsedType
      }), v;
    }
    return { status: "valid", value: e.data };
  }
}
Et.create = (t) => new Et({
  typeName: y.ZodNaN,
  ...w(t)
});
class Qr extends x {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
I.lazycreate;
var y;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded";
})(y || (y = {}));
const P = ve.create, Ue = ke.create;
Et.create;
pt.create;
const Nn = mt.create;
Le.create;
yt.create;
vt.create;
gt.create;
Oe.create;
re.create;
_t.create;
Y.create;
const R = I.create;
I.strictCreate;
const Ce = Ye.create;
Ct.create;
Ge.create;
G.create;
Je.create;
Tt.create;
Pe.create;
Me.create;
xt.create;
const Q = St.create;
$t.create;
Ot.create;
Ze.create;
se.create;
K.create;
Re.create;
se.createWithPreprocess;
const g = {
  oneTimeAccountsRead: Q("oneTimeAccountsRead"),
  ongoingAccountsRead: Q("ongoingAccountsRead"),
  oneTimePersonaDataRead: Q("oneTimePersonaDataRead"),
  ongoingPersonaDataRead: Q("ongoingPersonaDataRead"),
  usePersonaRead: Q("usePersonaRead"),
  loginRead: Q("loginRead"),
  sendTransactionWrite: Q("sendTransactionWrite")
}, es = Q("rejectedByUser"), Nt = R({
  address: P(),
  label: P(),
  appearanceId: Ue()
}), jn = R({
  account: Nt,
  challenge: P(),
  signature: P()
}), Mn = R({
  field: P(),
  value: P()
}), ts = R({
  networkId: Ue(),
  dAppId: P()
}), ns = R({
  requestType: g.oneTimeAccountsRead,
  requiresProofOfOwnership: Nn(),
  numberOfAccounts: Ue().optional()
}), rs = R({
  requestType: g.oneTimeAccountsRead,
  accounts: jn.array()
}), ss = R({
  requestType: g.oneTimeAccountsRead,
  accounts: Nt.array()
}), is = Ce([
  rs,
  ss
]);
R({
  requestType: g.ongoingAccountsRead,
  requiresProofOfOwnership: Nn(),
  numberOfAccounts: Ue().optional()
});
const os = R({
  requestType: g.ongoingAccountsRead,
  accounts: jn.array()
}), as = R({
  requestType: g.ongoingAccountsRead,
  accounts: Nt.array()
}), us = Ce([
  os,
  as
]);
R({
  requestType: g.oneTimePersonaDataRead,
  fields: P().array()
});
const cs = R({
  requestType: g.oneTimePersonaDataRead,
  fields: Mn.array()
});
R({
  requestType: g.ongoingPersonaDataRead,
  fields: P().array()
});
const ls = R({
  requestType: g.ongoingPersonaDataRead,
  fields: Mn.array()
});
R({
  requestType: g.usePersonaRead,
  id: P()
});
const ds = R({
  requestType: g.usePersonaRead,
  id: P()
});
R({
  requestType: g.loginRead,
  challenge: P().optional()
});
const fs = R({
  requestType: g.loginRead,
  personaId: P()
}), hs = R({
  requestType: g.loginRead,
  personaId: P(),
  challenge: P(),
  publicKey: P(),
  signature: P(),
  identityComponentAddress: P()
}), ps = Ce([
  fs,
  hs
]), ms = R({
  requestType: g.sendTransactionWrite,
  transactionManifest: P(),
  version: Ue(),
  blobs: P().array().optional(),
  message: P().optional()
}), ys = R({
  requestType: g.sendTransactionWrite,
  transactionIntentHash: P()
}), vs = Ce([
  ns,
  ms
]), gs = Ce([
  is,
  us,
  cs,
  ls,
  ds,
  ps,
  ys
]), _s = R({
  requestId: P(),
  items: vs.array(),
  metadata: ts
}), ws = R({
  requestId: P(),
  items: gs.array()
}), bs = R({
  requestId: P(),
  error: es,
  message: P().optional()
}), Ts = Ce([
  ws,
  bs
]), Ht = (t) => J.fromPromise(
  _s.parseAsync(t),
  (e) => e.issues
).map(() => t).mapErr(() => (H.error("ðŸ”µðŸ’¥ invalid wallet request"), He(
  pe.walletRequestValidation,
  t.requestId
))), Kt = (t) => J.fromPromise(
  Ts.parseAsync(t),
  (e) => e.issues
).map(() => t).mapErr(() => (H.error("ðŸ”µðŸ’¥ invalid wallet response"), He(
  pe.walletRequestValidation,
  t.requestId
))), Yt = (t) => t.reduce((e, n) => {
  switch (n.requestType) {
    case g.usePersonaRead.value: {
      const { requestType: r, ...s } = n;
      return { ...e, persona: s };
    }
    case g.loginRead.value: {
      const { requestType: r, ...s } = n;
      return { ...e, login: s };
    }
    case g.oneTimeAccountsRead.value: {
      const { requestType: r, ...s } = n;
      return { ...e, oneTimeAccounts: s.accounts };
    }
    case g.ongoingAccountsRead.value: {
      const { requestType: r, ...s } = n;
      return { ...e, ongoingAccounts: s.accounts };
    }
    case g.oneTimePersonaDataRead.value: {
      const { requestType: r, ...s } = n;
      return { ...e, oneTimePersonaData: s.fields };
    }
    case g.ongoingPersonaDataRead.value: {
      const { requestType: r, ...s } = n;
      return { ...e, ongoingPersonaData: s.fields };
    }
    case g.sendTransactionWrite.value: {
      const { requestType: r, ...s } = n;
      return { ...e, ...s };
    }
    default:
      return e;
  }
}, {}), M = {
  oneTimeAccountsWithoutProofOfOwnership: "oneTimeAccountsWithoutProofOfOwnership",
  oneTimeAccountsWithProofOfOwnership: "oneTimeAccountsWithProofOfOwnership",
  ongoingAccountsWithoutProofOfOwnership: "ongoingAccountsWithoutProofOfOwnership",
  ongoingAccountsWithProofOfOwnership: "ongoingAccountsWithProofOfOwnership",
  usePersona: "usePersona",
  loginWithoutChallenge: "loginWithoutChallenge",
  loginWithChallenge: "loginWithChallenge",
  oneTimePersonaData: "oneTimePersonaData",
  ongoingPersonaData: "ongoingPersonaData"
}, xs = (/* @__PURE__ */ new Map()).set(
  M.oneTimeAccountsWithoutProofOfOwnership,
  g.oneTimeAccountsRead.value
).set(
  M.oneTimeAccountsWithProofOfOwnership,
  g.oneTimeAccountsRead.value
).set(
  M.ongoingAccountsWithProofOfOwnership,
  g.ongoingAccountsRead.value
).set(
  M.ongoingAccountsWithoutProofOfOwnership,
  g.ongoingAccountsRead.value
).set(
  M.loginWithChallenge,
  g.loginRead.value
).set(
  M.loginWithoutChallenge,
  g.loginRead.value
).set(
  M.usePersona,
  g.usePersonaRead.value
).set(
  M.oneTimePersonaData,
  g.oneTimePersonaDataRead.value
).set(
  M.ongoingPersonaData,
  g.ongoingPersonaDataRead.value
).set("sendTransaction", g.sendTransactionWrite.value), Gt = (t) => q(
  Object.entries(t).reduce(
    (e, [n, r]) => {
      switch (n) {
        case M.oneTimeAccountsWithoutProofOfOwnership:
          return [
            ...e,
            {
              requestType: g.oneTimeAccountsRead.value,
              ...r,
              requiresProofOfOwnership: !1
            }
          ];
        case M.oneTimeAccountsWithProofOfOwnership:
          return [
            ...e,
            {
              requestType: g.oneTimeAccountsRead.value,
              ...r,
              requiresProofOfOwnership: !0
            }
          ];
        case M.ongoingAccountsWithProofOfOwnership:
          return [
            ...e,
            {
              requestType: g.ongoingAccountsRead.value,
              ...r,
              requiresProofOfOwnership: !0
            }
          ];
        case M.ongoingAccountsWithoutProofOfOwnership:
          return [
            ...e,
            {
              requestType: g.ongoingAccountsRead.value,
              ...r,
              requiresProofOfOwnership: !1
            }
          ];
        default:
          return [
            ...e,
            { requestType: xs.get(n), ...r }
          ];
      }
    },
    []
  )
), Jt = (t) => (e, n = crypto.randomUUID()) => q({
  items: e,
  requestId: n,
  metadata: t
}), Ss = {
  sendTransaction: "sendTransaction"
}, Os = {
  ...M,
  ...Ss
}, Es = (t, e) => ({
  request: (s, i = {}) => Gt(s).andThen(Jt(t)).asyncAndThen(Ht).andThen(e(i)).andThen(Kt).map((o) => o.items).map(Yt),
  sendTransaction: (s, i = {}) => Gt({ [Os.sendTransaction]: s }).andThen(Jt(t)).asyncAndThen(Ht).andThen(e(i)).andThen(Kt).map((o) => o.items).map(Yt)
});
var As = /* @__PURE__ */ ((t) => (t.I8 = "i8", t.I16 = "i16", t.I32 = "i32", t.I64 = "i64", t.I128 = "i128", t.U8 = "u8", t.U16 = "u16", t.U32 = "u32", t.U64 = "u64", t.U128 = "u128", t.Unit = "Unit", t.Bool = "Bool", t.String = "String", t.Enum = "Enum", t.Array = "Array", t.Tuple = "Tuple", t.PackageAddress = "PackageAddress", t.ComponentAddress = "ComponentAddress", t.ResourceAddress = "ResourceAddress", t.SystemAddress = "SystemAddress", t.Bucket = "Bucket", t.Proof = "Proof", t.Expression = "Expression", t.Blob = "Blob", t.NonFungibleAddress = "NonFungibleAddress", t.Hash = "Hash", t.EcdsaSecp256k1PublicKey = "EcdsaSecp256k1PublicKey", t.EcdsaSecp256k1Signature = "EcdsaSecp256k1Signature", t.EddsaEd25519PublicKey = "EddsaEd25519PublicKey", t.EddsaEd25519Signature = "EddsaEd25519Signature", t.Decimal = "Decimal", t.PreciseDecimal = "PreciseDecimal", t.NonFungibleId = "NonFungibleId", t))(As || {});
class U extends Error {
  constructor(e) {
    super(e);
  }
}
const li = () => "()", di = (t) => `${t}`, fi = (t) => {
  if (t < -128 || t > 127)
    throw new U("Number range exceeded i8");
  return `${t}i8`;
}, hi = (t) => {
  if (t < -32768 || t > 32767)
    throw new U("Number range exceeded i16");
  return `${t}i16`;
}, pi = (t) => {
  if (t < -2147483648 || t > 2147483647)
    throw new U("Number range exceeded i32");
  return `${t}i32`;
}, mi = (t) => {
  const e = BigInt(t);
  if (e < BigInt("-9223372036854775808") || e > BigInt("9223372036854775807"))
    throw new U("Number range exceeded i64");
  return `${t}i64`;
}, yi = (t) => {
  const e = BigInt(t);
  if (e < BigInt("-170141183460469231731687303715884105728") || e > BigInt("170141183460469231731687303715884105727"))
    throw new U("Number range exceeded i128");
  return `${t}i128`;
}, vi = (t) => {
  if (t < 0 || t > 255)
    throw new U("Number range exceeded u8");
  return `${t}u8`;
}, gi = (t) => {
  if (t < 0 || t > 65535)
    throw new U("Number range exceeded u16");
  return `${t}u16`;
}, _i = (t) => {
  if (t < 0 || t > 4294967295)
    throw new U("Number range exceeded u32");
  return `${t}u32`;
}, wi = (t) => {
  const e = BigInt(t);
  if (e < 0 || e > BigInt("18446744073709551615"))
    throw new U("Number range exceeded u64");
  return `${t}u64`;
}, bi = (t) => {
  const e = BigInt(t);
  if (e < 0 || e > BigInt("340282366920938463463374607431768211455"))
    throw new U("Number range exceeded u128");
  return `${t}u128`;
}, Ti = (t) => `"${t}"`, xi = (t, ...e) => e.length > 0 ? `Enum("${t}",${e.join(",")})` : `Enum("${t}")`, Si = (...t) => `Tuple(${t.join(",")})`, Oi = (t, ...e) => (Ps(t, e), `Array<${t}>(${e.join(",")})`), ks = (t) => `PackageAddress("${t}")`, ce = (t) => `ComponentAddress("${t}")`, N = (t) => `ResourceAddress("${t}")`, Ei = (t) => `SystemAddress("${t}")`, we = (t) => typeof t == "string" ? `Bucket("${t}")` : `Bucket(${t}u32)`, z = (t) => typeof t == "string" ? `Proof("${t}")` : `Proof(${t}u32)`, Ai = (t) => `Expression("${t}")`, ki = (t) => `Blob("${t}")`, Pi = (t, e) => `NonFungibleAddress("${t}", ${e})`, Ri = (t) => `Hash("${t}")`, Ii = (t) => `EcdsaSecp256k1PublicKey("${t}")`, Ci = (t) => `EcdsaSecp256k1Signature("${t}")`, $i = (t) => `EddsaEd25519PublicKey("${t}")`, Ni = (t) => `EddsaEd25519Signature("${t}")`, be = (t) => `Decimal("${t}")`, ji = (t) => `PreciseDecimal("${t}")`, Mi = (t) => `NonFungibleId(${t})`, Ps = (t, e) => {
  if (t === "String") {
    if (e.some((n) => !n.startsWith('"') && !n.endsWith('"')))
      throw new U(`Array<${t}> expects the same type`);
  } else if (t === "Unit") {
    if (e.some((n) => n !== "()"))
      throw new U(`Array<${t}> expects the same type`);
  } else if (e.some((n) => !n.includes(t)))
    throw new U(`Array<${t}> expects the same type`);
};
class Rs {
  constructor(e) {
    _e(this, "instructions");
    this.instructions = e;
  }
  toString() {
    return this.instructions.join(`
`);
  }
}
class Li {
  constructor() {
    _e(this, "instructions");
    _e(this, "buckets");
    _e(this, "proofs");
    _e(this, "id_allocator");
    this.instructions = [], this.buckets = /* @__PURE__ */ new Map(), this.proofs = /* @__PURE__ */ new Map(), this.id_allocator = 512;
  }
  takeFromWorktop(e, n) {
    return this.instructions.push(
      `TAKE_FROM_WORKTOP ${N(e)} ${we(
        n
      )};`
    ), this.buckets.set(n, this.id_allocator++), this;
  }
  takeFromWorktopByAmount(e, n, r) {
    return this.instructions.push(
      `TAKE_FROM_WORKTOP_BY_AMOUNT ${be(e)} ${N(
        n
      )} ${we(r)};`
    ), this.buckets.set(r, this.id_allocator++), this;
  }
  takeFromWorktopByIds(e, n, r) {
    return this.instructions.push(
      `TAKE_FROM_WORKTOP_BY_IDS ${e} ${N(
        n
      )} ${we(r)};`
    ), this.buckets.set(r, this.id_allocator++), this;
  }
  returnToWorktop(e) {
    return this.instructions.push(`RETURN_TO_WORKTOP ${we(e)};`), this;
  }
  assertWorktopContains(e) {
    return this.instructions.push(
      `ASSERT_WORKTOP_CONTAINS ${N(e)};`
    ), this;
  }
  assertWorktopContainsByAmount(e, n) {
    return this.instructions.push(
      `ASSERT_WORKTOP_CONTAINS_BY_AMOUNT ${be(e)} ${N(
        n
      )};`
    ), this;
  }
  assertWorktopContainsByIds(e, n) {
    return this.instructions.push(
      `ASSERT_WORKTOP_CONTAINS_BY_IDS ${e} ${N(
        n
      )};`
    ), this;
  }
  popFromAuthZone(e) {
    return this.instructions.push(`POP_FROM_AUTH_ZONE ${z(e)};`), this.proofs.set(e, this.id_allocator++), this;
  }
  pushToAuthZone(e) {
    return this.instructions.push(`PUSH_TO_AUTH_ZONE ${z(e)};`), this;
  }
  clearAuthZone() {
    return this.instructions.push("CLEAR_AUTH_ZONE;"), this;
  }
  createProofFromAuthZone(e, n) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_AUTH_ZONE ${N(e)} ${z(
        n
      )};`
    ), this.proofs.set(n, this.id_allocator++), this;
  }
  createProofFromAuthZoneByAmount(e, n, r) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_AUTH_ZONE_BY_AMOUNT ${be(
        e
      )} ${N(n)} ${z(r)};`
    ), this.proofs.set(r, this.id_allocator++), this;
  }
  createProofFromAuthZoneByIds(e, n, r) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_AUTH_ZONE_BY_IDS ${e} ${N(
        n
      )} ${z(r)};`
    ), this.proofs.set(r, this.id_allocator++), this;
  }
  createProofFromBucket(e, n) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_BUCKET ${we(e)} ${z(n)};`
    ), this.proofs.set(n, this.id_allocator++), this;
  }
  cloneProof(e, n) {
    return this.instructions.push(
      `CLONE_PROOF ${z(e)} ${z(n)};`
    ), this.proofs.set(n, this.id_allocator++), this;
  }
  dropProof(e) {
    return this.instructions.push(`DROP_PROOF ${z(e)};`), this;
  }
  callFunction(e, n, r, s) {
    return this.instructions.push(
      `CALL_FUNCTION ${ks(
        e
      )} "${n}" "${r}" ${s.join(" ")};`
    ), this;
  }
  callMethod(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${ce(
        e
      )} "${n}" ${r.join(" ")};`
    ), this;
  }
  callNativeFunction(e, n, r) {
    return this.instructions.push(
      'CALL_NATIVE_FUNCTION "' + e + '" "' + n + '" ' + r.join(" ") + ";"
    ), this;
  }
  callNativeMethod(e, n, r) {
    return this.instructions.push(
      "CALL_NATIVE_METHOD " + e + ' "' + n + '" ' + r.join(" ") + ";"
    ), this;
  }
  publishPackageWithOwner(e, n, r) {
    return this.instructions.push(
      'PUBLISH_PACKAGE_WITH_OWNER Blob("' + e + '") Blob("' + n + '") ' + r + ";"
    ), this;
  }
  createResource(e, n, r, s) {
    return this.instructions.push(
      `CREATE_RESOURCE ${e} ${n} ${r} ${s};`
    ), this;
  }
  burnBucket(e) {
    return this.instructions.push(`BURN_BUCKET ${we(e)};`), this;
  }
  mintFungible(e, n) {
    return this.instructions.push(
      `MINT_FUNGIBLE ${N(e)} ${be(n)};`
    ), this;
  }
  withdrawFromAccount(e, n) {
    return this.instructions.push(
      `CALL_METHOD ${ce(
        e
      )} "withdraw" ${N(n)};`
    ), this;
  }
  withdrawFromAccountByAmount(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${ce(
        e
      )} "withdraw_by_amount" ${be(n)} ${N(
        r
      )};`
    ), this;
  }
  withdrawFromAccountByIds(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${ce(
        e
      )} "withdraw_by_ids" ${n} ${N(
        r
      )};`
    ), this;
  }
  createProofFromAccount(e, n) {
    return this.instructions.push(
      `CALL_METHOD ${ce(
        e
      )} "create_proof" ${N(n)};`
    ), this;
  }
  createProofFromAccountByAmount(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${ce(
        e
      )} "create_proof_by_amount" ${be(n)} ${N(
        r
      )};`
    ), this;
  }
  createProofFromAccountByIds(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${ce(
        e
      )} "create_proof_by_ids" ${n} ${N(
        r
      )};`
    ), this;
  }
  build() {
    return new Rs(this.instructions);
  }
}
var Is = "Expected a function", Cs = 9007199254740991, $s = "[object Arguments]", Ns = "[object Function]", js = "[object GeneratorFunction]", Ms = typeof $e == "object" && $e && $e.Object === Object && $e, Ls = typeof self == "object" && self && self.Object === Object && self, Zs = Ms || Ls || Function("return this")();
function Us(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
function Ds(t, e) {
  for (var n = -1, r = e.length, s = t.length; ++n < r; )
    t[s + n] = e[n];
  return t;
}
var jt = Object.prototype, Ws = jt.hasOwnProperty, Ln = jt.toString, Xt = Zs.Symbol, qs = jt.propertyIsEnumerable, Qt = Xt ? Xt.isConcatSpreadable : void 0, en = Math.max;
function Zn(t, e, n, r, s) {
  var i = -1, o = t.length;
  for (n || (n = Fs), s || (s = []); ++i < o; ) {
    var a = t[i];
    e > 0 && n(a) ? e > 1 ? Zn(a, e - 1, n, r, s) : Ds(s, a) : r || (s[s.length] = a);
  }
  return s;
}
function Bs(t, e) {
  return e = en(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, r = -1, s = en(n.length - e, 0), i = Array(s); ++r < s; )
      i[r] = n[e + r];
    r = -1;
    for (var o = Array(e + 1); ++r < e; )
      o[r] = n[r];
    return o[e] = i, Us(t, this, o);
  };
}
function Vs(t) {
  return Bs(function(e) {
    e = Zn(e, 1);
    var n = e.length, r = n;
    for (t && e.reverse(); r--; )
      if (typeof e[r] != "function")
        throw new TypeError(Is);
    return function() {
      for (var s = 0, i = n ? e[s].apply(this, arguments) : arguments[0]; ++s < n; )
        i = e[s].call(this, i);
      return i;
    };
  });
}
function Fs(t) {
  return Hs(t) || zs(t) || !!(Qt && t && t[Qt]);
}
function zs(t) {
  return Ys(t) && Ws.call(t, "callee") && (!qs.call(t, "callee") || Ln.call(t) == $s);
}
var Hs = Array.isArray;
function Ks(t) {
  return t != null && Js(t.length) && !Gs(t);
}
function Ys(t) {
  return Qs(t) && Ks(t);
}
function Gs(t) {
  var e = Xs(t) ? Ln.call(t) : "";
  return e == Ns || e == js;
}
function Js(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Cs;
}
function Xs(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function Qs(t) {
  return !!t && typeof t == "object";
}
var ei = Vs(), ti = ei;
function Zi(...t) {
  return ti(t)({});
}
const ni = {
  withoutChallenge: () => (t) => ({
    ...t,
    loginWithoutChallenge: {}
  }),
  withChallenge: (t) => (e) => ({
    ...e,
    loginWithChallenge: { challenge: t }
  })
}, ri = {
  withoutProofOfOwnership: (t) => (e) => ({
    ...e,
    oneTimeAccountsWithoutProofOfOwnership: {
      numberOfAccounts: t
    }
  }),
  withProofOfOwnership: (t) => (e) => ({
    ...e,
    oneTimeAccountsWithProofOfOwnership: {
      numberOfAccounts: t
    }
  })
}, si = {
  withoutProofOfOwnership: (t) => (e) => ({
    ...e,
    ongoingAccountsWithoutProofOfOwnership: {
      numberOfAccounts: t
    }
  }),
  withProofOfOwnership: (t) => (e) => ({
    ...e,
    ongoingAccountsWithProofOfOwnership: {
      numberOfAccounts: t
    }
  })
}, ii = (t) => (e) => ({
  ...e,
  usePersona: { id: t }
}), oi = (...t) => (e) => ({
  ...e,
  oneTimePersonaData: { fields: t }
}), ai = (...t) => (e) => ({
  ...e,
  ongoingPersonaData: { fields: t }
}), Ui = {
  oneTimeAccounts: ri,
  ongoingAccounts: si,
  oneTimePersonaData: oi,
  ongoingPersonaData: ai,
  login: ni,
  usePersona: ii
}, ui = {
  Mainnet: 1,
  Stokenet: 2,
  Adapanet: 10,
  Nebunet: 11,
  Gilganet: 32,
  Enkinet: 33,
  Hammunet: 34
}, Di = ({
  networkId: t = ui.Mainnet,
  dAppId: e,
  logLevel: n = In.logLevel
}) => {
  H.setLevel(n), H.debug("ðŸ”µ wallet sdk instantiated");
  const r = Zr(), s = () => {
    H.debug("ðŸ”µðŸ§¹ destroying wallet sdk instance"), r.destroy();
  };
  return {
    ...Es(
      { networkId: t, dAppId: e },
      Hr(r.subjects)
    ),
    destroy: s,
    __subjects: r.subjects
  };
};
export {
  Oi as Array,
  ki as Blob,
  di as Bool,
  we as Bucket,
  ce as ComponentAddress,
  be as Decimal,
  Ii as EcdsaSecp256k1PublicKey,
  Ci as EcdsaSecp256k1Signature,
  $i as EddsaEd25519PublicKey,
  Ni as EddsaEd25519Signature,
  xi as Enum,
  Ai as Expression,
  Ri as Hash,
  yi as I128,
  hi as I16,
  pi as I32,
  mi as I64,
  fi as I8,
  Li as ManifestBuilder,
  ui as Network,
  Pi as NonFungibleAddress,
  Mi as NonFungibleId,
  ks as PackageAddress,
  ji as PreciseDecimal,
  z as Proof,
  N as ResourceAddress,
  U as ScryptoValueError,
  Ti as String,
  Ei as SystemAddress,
  Si as Tuple,
  As as TypeId,
  bi as U128,
  gi as U16,
  _i as U32,
  wi as U64,
  vi as U8,
  li as Unit,
  Di as default,
  Zi as requestBuilder,
  Ui as requestItem
};
